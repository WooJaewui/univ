
 분할정복 알고리즘(2)



 # 합병 정렬.

합병 정렬.
개념과 원리.
	● 분할 : 배열을 동일한 크기의 두 개의 부분배열로 분할.
	● 정복 : 각각의 부분배열을 순환적으로 정렬.
	● 결합 : 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦.
합병 함수 merge( )
	● 부분배열 A와 B사이의 첫번째 인자부터 비교하여 작은 값을 먼저 위치시켜서 정렬한다.
	● 두 부분배열 간의 비교 횟수 : O(n)
	● 입력 데이터 개수 n만큼의 추가 저장 장소 B[] + C[]가 필요.
	● 제자리 정렬 알고리즘이 아니다.
성능 분석.
	● T(n) = O( nlogn )

비순환적 합병 정렬.
분할, 정복을 하지 않고 merge( ) 반복하는 알고리즘.



 # 선택 문제.

선택 문제.
개념.
	● n개의 원소가 임의의 순서로 저장된 배열 A[ 0, ... , n-1 ] 에서 i 번째로 작은 원소를 찾는 문제.
직관적인 해결 방법.
	● 오름차순으로 정렬한 후 i번째 원소를 찾는 방법. O( nlogn )
	● 최솟값을 찾는 과정을 i번 반복. O( in )

최대값 최솟값 찾기.
min = 0;
value = { 임의의 값 }
for( int i =0; i<=value.length; i++ ) {
	if( value[i] < min ) { 
		min = value[i];
	}
}

i번째로 작은 원소 찾기 - 최악 O( n**2 ), 평균 O( n )
설명.
	● 퀵 정렬의 분할 함수 Partition( )을 순환적으로 적용하는 방법.
	● 피벗을 지정하고 피벗의 순서를 찾아서 정렬한다.
	● i = p, i < p, i > p에 따라 각각 다른 순환을 적용한다.
개념과 원리.
	● 분할 : 피벗을 기준으로 주어진 배열을 두 부분배열로 분할, i와 p를 비교.
	● 정복 : i가 포함된 부분배열에 대해서 알고맂므을 순환적으로 호출하여 적용.
	● 결합 : 필요 없음.
성능 분석.
	● 최악의 경우 : O( n**2 )
	● 평균 : O( n )

i번째로 작은 원소 찾기 - 최악 O( n ), 평균 O( n )
설명.
	● 항상 일정한 비율의 두 부분배열로 분할되도록 특정 성질을 만족하는 값을 피벗으로 선택.
피벗 선택 방법.
	● 크기 n인 배열의 원소를 5개씩 묶어서 [ n/5 ]개의 그룹을 만듦. ( 나머지는 버림 )
	● 각 그룹에 대해서 중간값을 찾음.
	● [ n/5 ] 개의 중간값을 대상으로 다시 중간값을 찾음.


