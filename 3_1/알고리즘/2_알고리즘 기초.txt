
 알고리즘 기초.



 # 알고리즘의 개념.

알고리즘 정의.
주어진 문제를 풀기 위한 명령어들의 단계적 나열.
입출력 , 명확성 , 유한성 , 유효성.
실용적 관점에서는 효율적이어야 함.

알고리즘 생성 단계.
설계 : 상향식 설계 , 하향식 설계.
표현 / 기술 : 일상 언어 , 순서도 , 의사 코드 , 프로그래밍 언어 , ... 
정확성 검증 : 수학적 증명 ( 수업시간에 배우지 않는다 )
효율적 분석 : 공간 복잡도 , 시간 복잡도.



 # 알고리즘의 설계.

최대값 찾기.
1. 값들을 하나씩 모두 비교해 가면서 찾는 방법.
2. 토너먼트 형식.
최소한 n-1 번 연산해야 된다.

뒤섞인 카드에서 원하는 카드 찾기.
순차 탐색 sequential search ( 앞에서부터 하나씩 뒤집어본다 ) 

순서대로 나열된 카드에서 원하는 카드 찾기.
이진 탐색 binary search ( 중간 카드를 뒤집어본다 )

알고리즘 설계 기법.
주어지는 문제, 속성, 조건 등이 매우 다양 ( 범용적인 설계 기법은 존재하지 않는다 )

대표적인 알고리즘 설계 기법.
분할정복 divide-and-conquer 방법.
동적 프로그래밍 dynamic programming 방법.
욕심쟁이 greedy 방법.



 # 알고리즘의 분석.

정확성 분석.
유효한 입력, 유한 시간 -> 정확한 결과 생성 여부.
다양한 수학적 기법을 사용해서 이론적인 증명이 필요.

효율성 분석.
알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정.
메모리 양 -> 공간 복잡도 space complexity. ( 정적 공간 + 동적 공간 )
수행 시간 -> 시간 복잡도 time complexity. 

시간 복잡도.
알고리즘의 단위 연산의 수행 횟수의 합.

시간 복잡도에 영향을 미치는 요인.
입력 크기 : 입력으로 제공되는 데이터의 크기. ( 행렬의 크기, 리스트 원소의 수 ) 
입력 데이터의 상태.

영향을 미치는 요인 해결 방안.
입력 크기 n이 증가하면 수행 시간도 증가 ( 입력 크기 n에 대한 함수 f(n)으로 표현 )
입력 데이터의 상태에 종속적 ( 최선 수행 시간 , 최악 수행 시간 - 평균 수행시간은 사용 불가 )

시간 복잡도 구하기.
f(n) = 3n + 5 ;



 # 점근성능.

점근성능.
입력 크기 n이 무한대로 커짐에 따라 결정되는 성능.

점근성능의 결정 방법.
수행 시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현.
수행 시간의 정확한 값이 아닌 어림값. 
-> 수행 시간의 증가 추세를 파악하는데 용이.
-> 알고리즘의 우열 표현이 용이.

Big-oh 점근적 상한.
어떤 양의 상수 c와 n0이 존재하여 모든 n >= n0에 대하여 
f(n) <= c * g(n) 이면 f(n) = O(g(n))이다.
최악 수행 시간을 표현.

Big-omega 점근적 하한.
어떤 양의 상수 c와 n0이 존재하여 모든 n >= n0에 대하여
f(n) >= c * g(n) 이면  f(n) = Ω(g(n))이다.
최선 수행 시간을 표현.

Big-theta 점근적 상하한.
어떤 양의 상수 c1, c2와 n0이 존재하여 모든 n >= n0에 대하여
c1 * g(n) <= f(n) <= c2 * g(n)이면 f(n) = Θ(g(n))이다.
최고, 최악 수행 시간의 사이 값을 표현.

점근성능의 수행시간.
O(1) -> O( logn ) -> O( n ) -> O( nlogn ) -> O( n**2 ) -> O( n**3 ) -> O( 2**n )
오른쪽으로 갈수록 데이터가 커짐에 따라 수행시간이 훨씬 오래 걸린다. ( 비효율적 ) 
2 ** n 은 실제로 사용할 수 없다.

알고리즘의 시간 복잡도 구하기.
알고리즘의 수행 시간 f(n)을 구한 후,
f(n) = O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾음.

실제 알고리즘 시간 복잡도 구하기.
알고리즘에 나타난 루프의 반복횟수를 조사하여 시간 복잡도를 취함.
중첩 반복문은 n x n 으로 나타낸다.



 # 순환 알고리즘의 성능.

순환 recursion.
알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태.

퀵 정렬의 최악의 수행 시간.
T( n ) = T( n-1 ) + c1 , T(1) = c1 -> ... -> O( n**2 )

이진 탐색의 수행 시간.
T( n ) = T( n/2 ) + c1 , T(1) = c1 -> ... -> O( logn )

합병 정렬의 수행 시간, 퀵 정렬의 최선의 수행 시간.
T( n ) = 2T( n/2 ) + c1 , T(1) = c1 -> ... -> O( nlogn ) 






