
 근사 알고리즘.



 # 기본 개념.

튜링 기계 Turing machine.
- 컴퓨터의 이론적 모델.
- 구성요소
	- 테이프, 기호, 헤드, 상태, 규칙.
	- 무한한 길이의 테이프, 유한한 개수의 기호와 상태, 상태와 기호에 따른 헤드의 동작을 정해둔 규칙.
	- 현재 상태와 읽은 기호에 따라 헤드가 테이프에 기호를 쓰거나 좌우로 이동.
- 주어진 테이프와 규칙에 따라 동작하는 기계.
	- 주어진 입력과 알고리즘으로 동작하는 컴퓨터. ( 현재 우리가 사용하는 컴퓨터 )

결정론적 deterministic 튜링 기계.
- 테이프의 위치를 바꾸거나 쓰인 기호를 바꿀 때 한 가지 상태로만 변경 가능.

비결정론적 non-deterministic 튜링 기계.
- 하나 이상의 상태로 바뀔 수 있거나 혹은 바뀔 상태가 없을 수 있음.
- 연산 결과가 상황에 따라 달라질 수 있는 연산을 수행.

다항 시간 polynomial time 알고리즘.
- 알고리즘의 수행 시간을 입력 크기 n에 대한 다항식으로 표현.
- O(2**n) : 지수 시간 알고리즘.

난이도에 따른 문제 분류.
- 쉬운 tractable 문제.
	- 결정론적 튜링 기계를 이용한 다항 시간 알고리즘이 존재하는 문제.
- 어려운 intractable 문제.
	- 결정론적 튜링 기계를 이용한 다항 시간 알고리즘의 존재 여부를 알 수 없는 문제.

형태에 따른 문제 분류.
- 판정 decision 문제.
	- 최솟값 또는 최댓값을 구하는 형태의 문제.

클래스 P.
- 결정론적 튜링 기계를 이용하여 다항 시간에 해결할 수 있는 모든 판정 문제의 집합.
- 쉬운 문제의 판정 문제 버전을 원소로 갖는 집합.

클래스 NP.
- 비결정론적 튜링 기계를 이용하여 다항 시간에 해결할 수 있는 모든 판정 문제의 집합.
- 최단 경로 문제의 판정 문제 버전 ∈ 클래스 NP.

클래스 P와 클래스 NP의 관계.
P ⊆ NP , P ≠ NP

변환.
- 문제 A가 문제 B로 변환된다.
- 문제 A의 입력과 출력을 문제 B의 입력과 출력으로 바꿀 수 있고, 여기에 문제 B를 해결하는 알고리즘을 



 # NP-완전 문제.

완전 complete 문제.
- 어떤 부류에 속하는 모든 문제가 그 부류에 속하는 어떤 문제 R로 다항식 시간 변환이 가능하다면,
  문제 R을 그 부류의 완전 문제라고 함.
- 해당 부류의 모든 문제를 대표하는 문제.
- 완전 문제 R을 다항 시간에 해결할 수 있다면 그 부류의 다른 모든 문제도 결국 다항 시간에 해결 가능.

NP-완전 문제.
- 클래스 NP에 속하는 모든 문제가 주어진 어떤 문제 A로 다항식 시간 변환되고, 문제 A가 클래스 NP에 속하는 경우,
  문제 A를 NP-완전 문제라고 함.

하드 hard 문제.
- 어떤 부류에 속하는 모든 문제가 어떤 문제 R로 다항식 시간 변환이 가능하면 문제 R을 그 부류의 하드 문제라고 함.
- 문제 R이 해당 부류에 속하는 조건이 없음.
- 해당 부류에 속하는 어떤 문제보다 풀기 어렵거나 비슷한 정도로 풀기 힘든 문제.

NP-하드 문제.
- 클래스 NP에 속하는 모든 문제가 주어진 어떤 문제 A로 다항식 시간에 변환되는 경우, 문제 A를 NP-하드 문제라고 함.

NP-완전 문제와 NP-하드 문제의 관계.
- 모든 NP-완전 문제는 NP-하드 문제이다.
- 하지만, 모든 NP-하드 문제가 NP-완전 문제는 아니다.

NP-완전 문제의 종류.
1. 외판원 문제.
2. 해밀토니언 사이클 문제.
3. 궤 채우기 문제.
4. 파티션 문제.
5. 클리크 판정 문제.
6. 버텍스 커버 문제.

NP-완전성의 증명.
- 알려진 하나의 NP-완전 문제 A가 해당 문제 B로 다항식 시간 변환됨을 보인다.
- 해당 문제를 푸는 비결정론적 튜링 기계가 존재함을 보인다.



 # 근사 알고리즘.

근사 알고리즘.
- 최적화 문제에 대해서 최적해에 가까운 해를 구하는 다항 시간 알고리즘.

외판원 문제의 근사 알고리즘.
- 최소 신장 트리 + 깊이 우선 탐색.
- 주어진 그래프의 최소 신장 트리를 구한다.
- 임의의 정점 하나를 루트 노드로 지정해서 최소 신장 트리를 깊이 우선 탐색 순서대로 정점을 나열하고 
  마지막에 첫 정점을 한 번 더 추가한다.

성능 분석.
- 최소 신장 트리 구하기 + 깊이 우선 탐색하기 + 사이클 비용 계산하기 => O( |V|**2 )

특징.
- 근사해는 최적해의 두 배를 넘지 않는다.
- 최소 신장 트리의 가중치는 최적해보다 작거나 같다.
- 근사해는 최소 신장 트리의 가중치의 두 배를 넘지 않는다.

정리.
- 최소 신장 트리의 가중치는 최적해보다 작거나 같고 근사해는 최소 신장 트리의 가중치의 두 배를 넘지 않으므로,
  근사해는 최적해의 두 배를 넘지 않는다.

궤 채우기 문제의 근사 알고리즘.
- 최초법.
	- 사용된 궤 중에서 선택활 물체를 넣을 수 있게 최초의 궤에 넣는다.
- 최선법.
	- 현재 물체를 넣었을 때 남는 부분이 가장 작게 되는 궤에 넣는다.
	- 현재 물체를 넣었을 때 남는 부분.
- 감소순 최초법.
	- 물체를 크기의 감소순으로 정렬.
- 감소순 최선법.
	- 물체를 크기의 감소순으로 정렬.

성능 분석.
- 이중 for 루프 : O(n**2)
- 정렬 : O( nlogn ).

특징.
- 4가지 모두 최적해를 보장하지 못함.
- 최초법/최선법의 근사해는 최적해의 두 배를 넘지 않음.
- 감소순 최적법/ 감소순 최선법의 근사해는 최적해의 1.5배를 넘지 않음.

버텍스 커버 문제.
- 주어진 그래프의 모든 간선과 맞닿은 최소 크기의 정점의 부분 집합을 찾는 문제.

근사해 도출 방법.
- 그래프에서 임의의 간선을 선택하여 이와 맞닿은 두 정점을 모두 버텍스 커버에 포함시킨다.
- 두 정점에 부수된 모든 간선을 그래프에서 제거하는 과정을 반복.








