
 학습 PLUS.



 # 알고리즘 학습에 앞서서.

배열/연결 리스트.
- 정의, 논리적/물리적 표현/구조, 삽입, 삭제, 접근 방법, 종류 등.

스택, 큐.
- 정의, 특징, 동작, 용어.

트리, 그래프.
- 정의, 용어, 구현.
- 이진 트리 => 정의, 특성, 종류.



 # 알고리즘의 기초.

알고리즘 정의 및 조건.
- 명령어의 단계적 나열.
- 입출력, 명확성, 유한성, 유효성 + ( 실용적 관점 ) 효율성.

대표적인 알고리즘 설계 기법.
- 분할정복 방법.
- 동적 프로그래밍 방법.
- 욕심쟁이 방법.

알고리즘 분석.
- 분석 -> 정확성 분석 + 효율성 분석.
- 효율성 분석.
	- 공간 복잡도 -> 메모리 양.
	- 시간 복잡도 -> 수행 시간. ( 책에서 배우는 내용 )
		- 입력 크기의 함수로 표현.
		- 최악의 수행 시간을 사용.

점근성능.
- 입력 크기가 무한대로 커짐에 따라 결정되는 성능.
- 수행 시간의 다항식 함수에서 계수 없이 최고차항으로 표현.

표기법.
- Big-oh O 최악의 시간. 
- Big-omega 최선의 시간. 
- Big-theta 평균 시간.

빅오 함수의 크기 관계.
O(1) < O(logn) < O(n) < O(nlogn) < O(n**2) < O(n**3) < O(2**n)

주요 점화식.
- 순환 알고리즘은 점화식으로 표현할 수 있다.
- 이진 탐색 : O(logn)
- 퀵 정렬 최악 : O(n**2)
- 퀵 정렬 최선 : O(nlogn)
- 합병 정렬 : O(nlogn)



 # 분할정복 알고리즘.

순환적으로 문제를 푸는 하향식 접근 방법.
- 원래 문제와 동일 -> 입력 크기만 작아짐.
- 서로 독립적.
- 처리 단계 -> 분할, 정복, 결합.

적용 알고리즘.
- 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제 ( 분할 함수, 중간값들의 중간값 )

이진 탐색.
- 정렬된 상태의 입력 데이터를 절반씩 줄여가면서 원하는 값을 찾는 방법.
- 성능 : O( logn )
- 삽입/삭제 시 정렬 상태 유지를 위해 데이터 이동이 발생.

퀵 정렬.
- 피벗이 제자리를 잡도록 하여 정렬하는 방식.
- 분할 함수 Partition() -> O(n)
- 최악 수행 시간 : O(n**2)
- 최선 수행 시간 : O(nlogn)
- 평균 수행 시간 : O(nlogn)
- 피벗 선택의 임의성이 보장되면 평균 수행 시간을 보일 가능성이 높음.

합병 정렬.
- 전형적인 분할정복 방법이 적용된 알고리즘.
- 합병 함수 Meger() : O(n)
- 성능 : O(nlogn)
- 입력 크기 n만큼의 추가적인 저장 장소가 필요.

선택 문제.
- 임의의 순서로 저장된 배열 A에서 i번째로 작은 원소를 찾느 문제.
- 최소값 찾기 -> (n-1)번 비교.
- 최소값과 최대값 모두 찾기 3/2(n-2)번 비교.
- Partition() 이용 -> 최악 O(n**2) , 평균 O(n)
- 중간값들의 중간값 이용 -> 최악 O(n), 평균 O(n)



 # 동적 프로그래밍 알고리즘.

원리.
최적성의 원리 -> 점화식 도출 -> 소문제의 해를 테이블에 저장.
-> 저장된 해를 이용해서 점차적으로 상위 문제의 해를 구함.

특징.
- 상향식 접근 방법.
- 최적화 문제 해결에 주로 사용.
- 소문제는 독립일 필요는 없음.

적용 알고리즘.
- 피보나치 수열, 연쇄 행렬 곱셈, 스트링 편집 거리, 플로이드 알고리즘, 저울 문제.

연쇄 행렬 곱셈 문제.
- n개의 행렬을 연쇄적으로 곱할 때 기본 곱셈 횟수가 최소가 되는 행렬의 곱셈 순서를 구하는 문제.
- C(i,j) = { C(i,k) + C(k+1,j) + di-1dkdj }
- 성능 : O(n**3)

스트링 편집 거리 문제.
문자열 x를 y로 변환하는 데 필요한 전체 편집 연산에 대한 최소 비용을 구하는 문제.

모든 정점 간의 최단 경로.
- 가중 방향 그래프에서 모든 조합의 두 정점 간의 최단 경로.
- 경유할 수 있는 정점의 범위를 1에서 |V|까지 하나씩 늘려가면서 최단 경로를 구하는 방법.
- 가정 -> 가중치의 합이 음수인 사이클이 존재하지 않음.

저울 문제.
- 무게 M인 물체를 n개의 추를 이용하여 양팔 저울로 달수 있는지 확인하는 문제.
- 가정 -> 추의 무게 wi와 물체의 무게 M은 모두 정수.
- 성능 : O(nm)
- M > 2**n이면 직관적인 방법보다 비효율적.



 # 욕심쟁이 방법.

원리.
- 각 단계에서 가장 최선이라고 여겨지는 해를 선택해 나감으로써 전체적인 최적해를 구하는 방법.
- 최적화 문제, 최적성의 원리.
- 각 단계에서 하나의 최적해만 고려 -> 전체적인 최적해를 구하지 못할 수 있다.

적용 알고리즘.
- 동전 거스름돈 문제, 배낭 문제, 크루스칼 알고리즘, 프림 알고리즘, 데이크스트라 알고리즘,
  작업 스케줄링 문제, 작업 선택 문제, 허프만 문제.

배낭 문제.
- 배낭에 들어있는 물체의 이익의 합이 최대가 되도록 물체를 넣는 방법을 찾는 문제.
- 가장 -> 물체를 쪼개서 넣을 수 있다.
- 단위 무게당 이익이 가장 큰 물체부터 쪼개서라도 최대한 넣는다.
- 성능 : O(n) , 정렬까지 고려하면 O(nlogn)
- 0/1 배낭 문제는 욕심쟁이 방법으로 해결 불가. ( 물체를 쪼갤 수 없다 )

최소 신장 트리.
- 가중 무방향 그래프에 대한 트리 중에서 간선의 가중치의 합이 가장 작은 트리.
- 그래프가 트리가 되는 조건 -> 무방향, 모든 정점 연결, 무사이클.

크루스칼 알고리즘.
- 서로 다른 연결 성분에 속하는 정점을 잇는 최소 가중치의 간선을 선택.
- O( |E|log|E| )

프림 알고리즘.
- S와 V-S를 잇는 간선 중에서 가중치가 최소인 간선을 선택.
- 인접 행렬 O( |V|**2 ), 인접 리스트+힙 O( (|V| + |E|)log|V| )

데이크스트라 알고리즘 - 단일 출발점 최단 경로.
- 특정한 하나의 정점에서 다른 모든 정점으로의 최단 경로.
- 가정 -> 음의 가중치를 갖는 간선이 없어야 한다.
- V-S에서 거리 d[]가 최소인 정점 u를 선택 -> u의 인접 정점 v에 대해 d[v]= min을 반복해서 계산.

작업 스케줄링 문제.
- 최소의 기계를 사용해서 충돌 없이 모든 작업을 기계에 할당하는 문제.
- 몇개의 기계가 필요한지 구하는 방법.
- 시작 시간이 빠른 작업을 우선 선택.
- O(nlogn) 

작업 선택 문제.
- 하나의 기계만을 사용해서 충돌 없이 최대 개수의 작업을 할당하는 방법.
- 완료 시간이 빠른 작업을 우선 선택.
- O(nlogn)

허프만 코딩.
- 문자의 출현 빈도수에 따라 다른 길이의 부호를 부여.
- 접두부 코드, 최적 코드.
- 성능 -> O(nlogn+m) 
- 각 문자의 빈도수를 모르면 텍스트를 두 번 읽어야 하므로 속도 저하.
- 디코딩을 위한 정보 저장으로 인해 실제 압축률 저하.

인코딩 과정.
- 각 문자의 출현 빈도수 계산.
- 허프만 트리를 통해 각 문자의 이진 코드 부여.
- 주어진 텍스트에 대해 압축된 텍스트 생성.

허프만 트리.
- 욕심쟁이 방법, 전 이진 트리.
- 각 문자가 개별적인 트리인 상태에서 빈도수가 가장 작은 두 트리를 합치는 과정을 반복.
- 허프만 트리는 유일하지 않음. ( 인코딩된 메시지는 다르지만, 메시지의 길이는 동일 )








