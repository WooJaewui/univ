
 탐색 알고리즘(1)



 # 탐색의 개념.

탐색.
- 여러 데이터 중에서 원하는 값을 가진 데이터를 찾는 것.
	- 데이터 형태 -> 리스트, 트리, 그래프 등.
	- 내부 탐색 vs 외부 탐색.
	- 연산 -> 탐색 + 초기화(정렬), 삽입, 삭제 등을 고려해야 한다.

탐색 종류.
- 순차 툼색.
- 이진 탐색.
- 탐색 트리 -> 이진 탐색 트리, 균형 탐색 트리.
- 해싱.
	- 해시 함수, 충동 해결 방법.



 # 순차 탐색.

개념과 원리.
- 리스트 형태로 주어진 원소들에 대해서 처음부터 하나씩 차례대로 비교하면서 원하는 값을 찾는 방법.

성능 분석.
- 탐색 실패의 경우 -> 항상 n번 비교 -> O(n)
- 탐색 성공의 경우 -> 최소 1번 ~ 최대 n번 비교 -> O(n)
- 삽입 -> O(1)
- 삭제 -> O(n) ( 삭제할 데이터에 대한 탐색이 필요 )

특징.
- 모든 리스트에 적용 가능.
- 원소가 무순서로 연속해서 저장된 비정렬 데이터 탐색에 적합.



 # 이진 탐색.

개념과 원리.
- 정렬된 리스트 형태로 주어진 원소들을 절반씩 줄여가면서 원하는 값을 가진 원소를 찾는 방법.
- 중간 값을 확인하고 크기에 따라 왼쪽 오른쪽 집합을 선택하면서 값을 찾는다.

성능 분석.
- 탐색 -> O(logn)
- 초기화 -> O(nlogn)
- 삽입/삭제 -> O(n)

특징.
- 정렬된 리스트에 대해서만 적용 가능.
- 삽입과 삭제가 빈번한 경우에는 부적합.
	- 삽입/삭제 후 정렬 상태를 유지하기 위해서 자료 이동이 필요.



 # 이진 탐색 트리.

이진 탐색 트리 binary search tree.
- 이진 트리.
- 각 노드의 왼쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 작다.
- 각 노드의 오른쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 크다.

삭제 연산.
- 자식 노드가 없는 경우( 리프 노드의 경우 )
	- 남은 노드의 위치 조절이 불필요.
- 자식 노드가 하나인 경우.
	- 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따라 올린다.
- 자식 노드가 두 개인 경우.
	- 삭제되는 노드의 후속자 노드를 삭제되는 노드의 위치로 올린다.
	- 후속자 노드를 삭제되는 노드로 취급하여 자식 노드의 개수에 따라 처리.

성능 분석.
- 키 값을 비교하는 횟수에 비례 -> 이진 트리의 높이가 h라면 O(h)
- 평균 수행 시간 -> O(logn)
- 최악 수행 시간 -> O(n)

특징.
- 삽입/삭제 연산 시 기존 노드의 이동이 거의 발생하지 않음.
- 원소의 삽입/삭제에 따라 경사 트리 형태가 될 수 있음.
	- 최악의 수행 시간 O(n)
	- 경사 트리가 되지 않도록 균형을 유지해서 O(logn)을 보장. ( 균형 탐색 트리 )



