
 동적 프로그래밍 알고리즘(1)



 # 동적 프로그래밍 방법의 원리.

동적 프로그래밍 원리.
● 문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법.
● 해를 구축하는 테이블을 이용한다.
● 최적화 문제에 적용. ( 최솟값/ 최댓값을 구하는 문제 )

동적 프로그래밍 방법을 적용하려면.
● 최적성의 원리 principle of optimality를 반드시 만족해야 함.
● 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성된다.

동적 프로그래밍 방법의 적용 과정.
1. 문제의 특성을 분석하여 최적성의 원리가 성립되는지 확인.
2. 주어진 문제에 대해서 최적해를 제공하는 점화식을 도출.
3. 가장 작은 소문제부터 점화식의 해를 구해서 테이블에 저장.
4. 테이블에 저장된 소문제의 해를 이용하여 점차적으로 큰 상위 문제의 해를 구함.



 # 피보나치 수열.

피보나치 수열.
f(n)   =	f(n-1) + f(n-2),  n>=2
	f(0) = 0,	        f(1)=1

피보나치 수열 특징.
● 분할정복 방법을 적용하면 중복된 계산이 발생해서 매우 비효율적이다.



 # 연쇄 행렬 곱셈 문제.

개념과 원리.
● n개의 행렬( M1, ... Mn )을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제.
● 최적의 곱셈 순서 => 최소의 기본 곱셈 횟수를 갖는 행렬의 곱셈 순서.
● 2개의 행렬의 곱 => ( m x n ) ( n x z ) = m x n x z  => ( m x z ) 의 행렬이 생성된다.

최적성의 원리.
● n개의 행렬을 곱하는 최적의 순서는 n개의 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함.

점화식 도출.
C( i , j ) , 1<=i<=j<=n  => M(i) x M(i+1) x ... M(j)
	=> min i<=k<=j-1 { C(i,k) + C(k+1,j) +di-1dkdj } 
	=> k위치를 저장해 놓는다. ( j-1 )
	=> C( i, k ) + C( k+1, j ) + ( di * dk * dj )

성능 분석.
● O( n**3 )
● for( s=1; s<= ( n-1 ); s++ ) {
	for( i=1; i<= ( n-s ) ; i++ ) { 
		C[i][j] = min i<=k<=j-1 ( ... ) ;
	}
   }



