
 탐색 알고리즘(2)



 # 흑적 트리.

흑적 트리 red-black tree.
- 이진 탐색 트리, 균형 탐색 트리.

흑적 트리 성질.
1. 모든 노드는 흑색이거나 적색이다.
2. 루트 노드와 리프 노드는 흑색이다.
	- 모든 리프 노드는 Null 노드이다.
3. 적색 노드의 부모 노드는 흑색이다.
	- 적색 노드가 연달아 나타날 수 없다.
4. 임의의 노드로부터 리프 노드까지의 경로 상에는 동일한 개수의 흑색 노드가 존재한다.

탐색 연산.
- 이진 탐색 트리에서의 탐색 방법과 동일.

삽입 연산.
- 탐색이 실패한 Null 노드에 적색 노드를 추가.
- 두 자식 노드를 Null 노드로 만듦.
- 적색 노드가 연달아 나타나는 경우에 적용하는 규칙.
	- 부모 노드의 형제 노드가 적색인 경우, 색깔을 모두 변경.
	- 부모 노드의 형제 노드가 흑색이고, 현재 노드의 키 값이 부모와 조부모 사이일 때, 값을 변경.
	- 부모 노드의 형제 노드가 흑색이고, 현재 노드의 키 값이 부모와 조부모 값보다 크거나 작을 때, 값과 색을 변경.

성능분석.
- 탐색 시간 : O(logn)
- 삽입/삭제 시간 : O(logn)

특징.
- 사실상 이진 탐색 트리.
- 삽입 연산은 회전, 색깔 변경과 같은 추가 연산이 필요.
- 2-3-4 트리를 이진 탐색 트리로 표현한 것.



 # B-트리.

B-트리.
- 균형 탐색 트리.

B-트리 성질.
- 루트 노드는 한 개 이상 2t개 미만의 오름차순으로 정렬도니 키를 가짐.
- 루트 노드가 아닌 모든 노드는 (t-1)개 이상 2t개 미만의 오름차순으로 정렬된 키를 가짐.
- 내부 노드는 자신이 가진 키의 개수보다 하나 더 많은 자식 노드를 가짐.
- 한 노드의 한 키의 왼쪽 서브트리에 있는 모든 키값은 그 키값보다 작고, 오른쪽 서브트리에 있는 모든 키값은 그 키값보다 크다.
- 모든 리프 노드의 레벨은 동일하다.

삽입 연산.
- 루트 노드에서부터 탐색을 수행하여 리프 노드에도 존재하지 않으면 해당 노드에 추가.
- 노드 분할 : 삽입을 위한 탐색 과정에서 (2t-1)개의 키를 갖는 노드를 만나면,
	    이 노드를 (t-1)개의 키를 갖는 두 개의 노드로 분할.

성능 분석.
- 트리의 높이 h, 각 노드에서 키의 위치를 찾는 시간 O(t) -> O(th)
	- 각 노드에서는 (t-1) ~ (2t-1)개의 키와 t~2t개의 자식 노드를 가짐.
	- 몯느 리프 노드의 레벨은 동일.
- 트리의 높이 -> O(logtn) ( n: 키의 개수 )
- 각 노드에서의 키 관리에 흑적 트리를 이용하면 O(t) -> O(logt)
- O(logtlogtn) -> O(logn)

특징.
- 내부 탐색과 외부 탐색에 모두 활용.



 # 해싱.

해싱.
- 탐색 키값을 기반으로 데이터의 저장 위치를 직접 계산.
	- 상수 시간 내에 데이터의 탐색, 삽입, 삭제 가능.

충돌 collision.
- 키에 대한 값이 여러개인 경우를 의미한다.

해시 함수.
- 키 값을 해시 테이블 주소로 변환하는 함수.
- 제산 잔여법, 비닝, 중간 제곱법, 문자열을 위한 함수 등.

바람직한 해시 함수.
- 계산이 용이해야 한다.
- 각 키값을 테이블의 각 슬롯에 균등하게 사상시킬 수 있어야 한다.

제산 잔여법.
- h(K) = K mod M ( K : 키값, M : 해시 테이블의 크기 )
- M의 선택에 주의해야 함.
	- 키값의 전체 비트를 주소 계산에 활용하지 못함.

비닝.
- U를 단순히 M 등분하여 각 등분을 각 슬롯으로 해시.
- U는 키값의 범위, M은 해시 테이블 크기.

중간 제곱법.
- h(K) = (K**2 / 2**m) mod 2**r
- 주어진 키값을 제곱한다.
- 제곱된 결과를 키값의 자릿수로 나눈 후, M에 해당하는 하위 2자리 십진수를 취한다.

충돌 해결 방법.
- 개방 해싱(연쇄법)
	- 충돌된 데이터를 테이블 밖의 별도의 장소에 저장/관리.
- 폐쇄 해싱(개방 주소법)
	- 테이블 내의 다른 슬롯에 충돌된 데이터를 저장/관리.
	- 버킷 해싱, 선형 탐사, 이차 탐사, 이중 해싱.

버킷 해싱.
- 해시 테이블을 버킷 단위로 나눠서 저장하는 방식.
- 오버 플로우가 발생하면 오버 플로우 버킷에 저장한다.
- 디스크에 저장된 해시 테이블을 구현하는 데 적합.

탐사 순서 probe sequence.
- 어떤 키 K에 대해서 탐사되는 슬롯의 순서열.
- 탐사 순서의 계산 방법에 따라 성능의 차이가 발생.
	- 선형 탐사, 이차 탐사, 이중 해싱.

선형 탐사 linear probing.
- p(K,i) = ( h(K) + i ) mod M ( i= 0,1,2,...,M-1 )
	- 빈 슬롯을 찾을 때까지 테이블의 바로 다음 슬롯으로 순차적으로 이동.
- 모든 슬롯이 새로운 데이터를 삽입할 후보가 됨.
- 1차 클러스트링 문제.
	- 데이터들이 연속된 위치를 점유하여 클러스터를 형성하고, 이것이 점점 커지는 현상.

이차 탐사.
- 탐사 순서의 계산에 이차식을 이용.
- p(K,i) = ( h(K) + c1x(i**2) + c2xi + c3 ) mod M
- 서로 다른 홈 위치를 갖는 두 키는 서로 달느 탐사 순서를 갖게 됨.
- 모든 슬롯이 탐사 순서에 사용되지 않음.
- 2차 클러스트링 문제.
	- 해시 함수가 특정 홈 위치에 대한 클러스터를 만드는 현상.
	- 서로 다른 두 키의 홈 위치가 동일하면 전체 탐사 순서가 동일.

이중 해싱.
- 탐사 순서를 원래의 키값을 이용하여 계산.
- 1차/2차 클러스트터링 문제 해결.
- p(K,i) = ( h1(K) + ixh2(K) ) mod M
- 좋은 이중 해싱을 구하려면 탐사 순서의 모든 상수가 테이블 크기 M과 서로소가 되어야 함.

삭제 연산.
- 데이터 삭제가 차후의 탐색을 방해하지 않아야 한다.
	- 단순히 빈 슬롯으로 두면 탐색이 해당 슬롯에서 종료. ( 이후 레코드는 고립됨 )
- 삭제로 인해서 해시 테이블의 위치에서 사용할 수 없는 곳을 만들지 않아야 한다.

비석 tombstone.
- 삭제된 데이터의 위치에 비석이라는 특별한 표시를 하는 방법.
- 탐색 : 비석을 무시하고 탐색을 계속 진행.
- 삽입 : 비석이 표시된 위치를 빈 위치로 간주하여 새 데이터를 삽입.
- 비석의 개수가 증가할수록 평균 탐색 거리가 증가하는 문제.




