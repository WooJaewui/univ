
 정렬 알고리즘(2)



 # 합병 정렬과 퀵 정렬.

합병 정렬의 성능과 특징.
- 최선/최악/평균 수행 시간이 모두 O(nlogn) 
- 안정적인 정렬 알고리즘.

퀵 정렬의 성능과 특징.
- 최악 수행시간 O(n**2)
- 최선/평균 수행 시간 O(nlog)
	- 피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음.
- 제자리 정렬 알고리즘.
- 안정적이지 않은 정렬 알고리즘.



 # 힙 정렬.

힙.
- 완전 이진 트리.
- 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같다.
- 최대 힙 : 루트 노드에 최대값이 있는 힙.
- 최소 힙 : 루트 노드에 최솟값이 있는 힙.

개념과 원리.
- 힙 자료구조의 장점을 활용한 정렬.

힙의 장점.
- 임의의 값 삽입과 최댓값 삭제가 용이.

힙의 구현.
- 일반적인 이진 트리는 연결 리스트로 구현하지만, 힙은 1차원 배열로 구현한다.

힙 정렬의 처리 과정.
1. 1차원 배열 -> 힙으로 변환.
2. 최대값을 반복, 힙 정렬 ( 반복 )

초기 힙 구축 방법.
1. 주어진 입력 배열의 각 원소에 대해 힙에서의 삽입 과정을 반복.
2. 입력 배열을 완전 이진 트리로 만든 다음에 아래->위 , 오른쪽->왼쪽으로 힙 정렬.



 # 비교 기반 정렬 알고리즘.

키값을 직접적으로 비교해서 크기에 따라 순서를 정하는 방식.
- 기본 성능 : O(n**2) => 버블 정렬, 선택 정렬, 삽입 정렬, 셸 정렬.
- 향상된 성능 : O(nlogn ) => 합병 정렬, 퀵 정렬, 힙 정렬.

비교 기반으로 O(nlogn)보다 더 효율적인 성능의 정렬 알고리즘은 존재하는가 ?
- 비교 기반 정렬 알고리즘이 아무리 빨라도 O(nlogn)보다 빠를 순 없다.



 # 계수 정렬.

개념의 원리.
- 비교 기반이 아닌 데이터의 분포를 이용한 정렬 방식.
- 주어진 원소 중에서 자신보다 작거나 같은 값을 갖는 원소의 개수를 계산하여 정렬할 위치를 찾아 정렬.
- 입력값이 어떤 작은 정수 범위 내에 있다는 것을 알고 있는 경우에만 적용 가능.

성능분석.
- O(n+k)
- 입력값의 범위가 입력 원소의 개수보다 작거나 비례할 때 O(n)

특징.
- 입력값의 범위가 입력 원소의 개수보다 작거나 비례할 때 유용.
- 안정적인 정렬 알고리즘.
- 제자리 정렬 알고리즘이 아님.
- 보편적이지 못한 방법.
	- 입력값의 범위를 미리 알아야 함.
	- 추가적인 배열이 필요.



 # 기수 정렬.

개념과 원리.
- 입력값을 자릿수별로 부분적으로 비교하는 정렬.
- 각 자릿수별로 계수 정렬과 같은 안정적인 정렬 알고리즘을 반복적으로 적용하여 정렬하는 방식.

LSD Least Significant Digit.
- 낮은 자리수부터 높은 자리로 진행.

MSD Most Significant Digit.
- 높은 자리수부터 낮은 자리로 진행.

성능분석.
- O(dn)
- d가 입력 크기 n보다 매우 작으면 O(n)

특징.
- 입력 원소의 값의 자릿수가 상수일 때 유용.
- 안정적인 정렬 알고리즘.
- 제자리 정렬 알고리즘이 아님. ( 추가 공간 필요 )





















