
 메모리 관리.



 # 프로세스와 메모리.

프로세스의 동작.
프로그램 카운터를 참조하여 메모리로부터 수행될 명령을 읽어 CPU의 해당 명령을 수행.

기억장치 계층구조.
적절한 비용으로 높은 성능을 낼 수 있도록 계층적으로 구성.
CPU에 가까울수록 접근속도가 빠름, 비트당 기억장치 비용이 높음.
CPU에 가까울수록 용량이 작다.

메모리 관리.
메모리 호출.
	● 언제 새로운 프로세스를 메모리에 둘 것인가 ?
메모리 배치.
	● 실행될 프로세스를 메모리 내의 어느 곳에 둘 것인가 ?
메모리 교체.
	● 메모리가 꽉 찬 상태에서 새로운 프로세스를 적재해야 한다면 어떤 프로세스를 제거 ?
그 외.
	● 메모리를 고정 분할할 것인가 동적 분할할 것인가 ?
	● 프로세스의 적재 영역이 고정적인가 유동적인가 ?



 # 단일 프로그래밍 환경.

초기의 시스템.
오직 하나의 프로세스만 메모리를 전용으로 사용.
프로세스는 하나의 연속될 블록으로 메모리에 할당( 연속 메모리 할당 )

단일 프로그래밍 문제점.
메모리 용량을 초과하는 프로세스는 실행 불가.
메모리 낭비.
	● 당장 사용되지 않는 프로세스의 영역도 계속 적재.
자원의 낭비.
	● 하나의 자원이 사용되는 동안 다른 자원은 사용되지 않는다.



 # 다중 프로그래밍 환경.

다중 프로그래밍( 멀티 프로그래밍 )
여러 개의 프로세스가 메모리에 동시에 적재되는 것.
CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가.
	● 여러 프로세스가 동시에 진행되기 때문에 자원을 충분히 활용할 수 있다.

메모리 분할.
여러 프로세스를 메모리에 적재하기 위하여 고안된 방법.
하나의 분할에 하나의 프로세스가 적재.

메모리 분할 방식.
1. 고정 분할.
	● 메모리를 여러 개의 고정된 크기의 영역으로 분할.
	● 프로세스 배치 방법 1.
		○ 분할된 크기에 맞게 프로세스를 적재한다.
		○ 절대 번역 및 적재. ( 주소값을 절대주소로 만든다 )
		○ 효율성 낮음.
	● 프로세스 배치 방법 2.
		○ 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할 영역에든 적재.
		○ 재배치 가능 번역 및 적재. ( 주소값을 상대주소로 만든다 )
		○ 복잡합.
	● 고정 분할의 문제점.
		○ 내부 단편화 : 프로세스 크기가 작으면 분할 영역 내에 남게 되는 메모리가 낭비됨.
		○ 프로세스의 크기를 미리 알고 그에 맞춰 고정 분할을 해야함. ( 실현 불가능 )
2. 동적 분할.
	● 메모리의 분할 경계가 고정되지 않음.
	● 각 프로세스에게 필요한 만큼의 메모리만을 할당.
	● 동적 분할의 문제점.
		○ 외부 단편화 : 메모리 할당 반환이 반복됨에 따라 공백 메모리가 흩어져 생김.
		○ 통합 : 인접된 공백을 더 큰 하나의 공백으로 만듦.
		○ 집약 : 메모리 내의 모든 공백을 하나로 모음.

메모리 보호.
여러 프로세스가 동시에 메모리에 상주하므로 프로세스가 다른 할당영역을 침범하지 않게 하는 것.
	﻿● 하한 레지스터, 상한 레지스터를 통해 분할된 영역에 메모리만 사용한다.



 # 메모리 배치기법.

메모리 배치기법.
새로 반입된 프로그램이나 데이터를 메모리의 어느 위치에 배치할 것인가를 결정.
종류.
● 최초 적합.
● 후속 접합.
● 최적 접합.
● 최악 접합.

최초 적합.
프로세스가 적재될 수 있는 빈 공간 중에서 가장 먼저 발견되는 곳을 할당.
빈 공간 리스트를 동해 공백 주소를 저장해놓고 사용한다.

후속 적합.
최초 적합의 변형으로 이전에 탐색이 끝난 그 다음 부분부터 시작.
이전에 공백3에 메모리가 저장되었다면 공백4부터 검색하여 데이터를 저장한다.

최적 적합.
필요한 공간을 제공할 수 있는 빈 공간 중에서 가장 작은 곳을 선택하여 할당.
프로세스 메모리와 가장 근접한 공백에 메모리를 적재한다.
가장 많이 사용되는 메모리 배치방법이다.

최악 적합.
필요한 공간을 제공할 수 있는 빈 공간 중에서 가장 큰 곳을 선택하여 할당.






