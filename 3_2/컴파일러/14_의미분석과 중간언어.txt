
 의미분석과 중간언어.



 # 의미 분석.

의미 분석.
어휘분석기 문법에 맞으면 이 문법이 어떤 의미를 갖는지 확인하는 것이다.

상수정의 과정.
상수 이름 기호표에 등록.
이후 기억장소 배정 및 초기값 설정.

변수의 유형선언.
변수의 유형에 따른 유형설명자와 변수명칭이 기호표에 함께 등록. 
각 변수는 기억장소 배정.

유형( Type )정의 과정.
유형의 자료구조 구성 및 보관.
유형설명자( 유형의 자료구조 크기, 성격 등 )작성.
이후 기억장소 배정 때 정보 제공.

프로시저 선언.
프로시저 시작의 의미.
레벨로 블록구조 프로그램 허용.
레이블( label ) 선언.



 # 기호표 Symbol Table.

선형리스트.
가장 간단하고 쉽게 구현할 수 있는 방법.

선형리스트 조회시간.
cn * n' + cn * m = cn( n'+m )
( 데이터 삽입 + 데이터 조회 )

이진트리.
검색 효율이 좋은 방법이다.

이진트리 조회시간.
n 개의 이름 삽입 : n log2 n
m 개의 이름 조회 : m log2 n
전체 시간 : (n+m)log2 n 
n > 50이면 선형리스트보다 효율적.

해쉬 Hash table.
가장 효율이 좋은 검색법.

해쉬 조회시간.
식별자 = n, 조회 = m인 경우,
조회시간 : n/k ( m + n )에 비례.

해쉬 문제점.
해쉬함수를 어떻게 정할 것인가 ?
충돌 발생시 처리 방법 ?



 # 상수정의와 의미 분석의 예.

유형.
OTHERID : 기타.
SIMPLEVARID : 단순변수.
TYPEID : 유형( Unsigned_Integer, Integer, ... )
FIELDID : 레코드 타입에서 나오는 것. ( ??? )
PROCID : 프로시저.
CONSTID : 상수.



 # 중간언어 종류.

중간언어의 장점.
컴파일러를 기능적으로 독립적인 여러 모듈들로 구성할 수 있다.
원시 프로그램의 이식성을 증가시킬 수 있다.
고급 원시언어와 저급 목적코드 간의 의미적 차이를 이어주는 교량 역할.
번역과정이 좀더 쉽게 표현되고 효율적으로 처리될 수 있다.
기계와 독립적인 최적화가 가능하다.
인터프리티브 컴파일링 시스템에서 인터프리터를 이용하여 실행할 수 있다.

단점.
목적코드로 직접 번역한 것 보다 컴파일 시간이 더 소요되고 비효울적인 코드를 생상한다.

형태의 따른 4분류.
Polish 표기법.
3-주소 코드. ( 수업시간에는 Triple, Quadruple 방식을 강의 )
트리 구조 코드.
가상 기계 코드.

후위 Postfix 표현.
연산자를 뒤로 보내는 방식.
변환이 쉽고 빠르며 중간언어로 적합.
코드이동이 불가능 - 최적화에 부적합.

Postfix 표현 예시.
b * c - d
b * c d -
b c * d - 

3주소 코드 - Triple 표현.
번호, 연산자( Op ) , 피연산자1, 피연산자2를 통해 연산을 한다.
코드이동이 불편하다. ( 최적화 부적합 )
수행순서를 추가해서 코드이동을 좀 더 편리하게 바꿈. ( 간접 Triple 표현 )

3주소 코드 - Quadruple 표현.
번호, 연산자( op ), 피연산자1, 피연산자2, 결과를 통해 연산을 한다.
코드이동을 쉽게해서 최적화에 적합하다.

AST Abstract Syntax Tree 구문트리.
중간언어의 한 종류로 트리 구조를 가지고 있다.

Syntax-directed translation.
구문분석을 하면서 구문구조에 따라 직접 중간코드를 생산하는 방법.
생성규칙 + 의미수행코드로 구성.
생성규칙이 사용될 때마다 의미수행 규칙을 수행하게 된다.



 # 구문지시적 변환.

불식 Bool.
A < B or C < D and F < G.
100 if A < B goto- ( true )
101 goto 102 ( false )
102 if C < D goto 104 ( true )
103 goto- ( false )
104 if F < G goto- ( true )
105 goto- ( false )

Backpatching.
문법에 결과에 따라 다른 문법이 영향을 받는 상황을 의미한다.
문법의 결과값을 저장해서 다른 문법에서 그 결과값을 사용해서 계산한다.

치환문 assignment statement.
식별자, 치환연산자, 식으로 나타내는 문장.
예) A -> id := E 

E의 변환.
E.PLACE : 식의 값을 저장하는 이름.
E.CODE : 식을 계산하는 일련의 3-주소코드.
NEWTEMP( )는 임시변수 생성 함수이다.

GEN( ).
중간 값을 만들어주는 함수이다.
예)  GEN( E.PLACE := E1.PLACE + E1.PLACE )




