
 컴파일러 개요.



 # 컴파일러의 개념.

컴파일러.
프로그래밍 언어를 번역해주는 번역기이다.

번역기의 종류.
어셈블러 : 어셈블리어 -> 기계어.
컴파일러 : 고급언어 -> 저급언어 - 어셈블리어 ( C, C++, Java )
인터프리터 : 고급언어 -> 실행결과. 
프리프로세서 : 고급언어 -> 고급언어. 

컴파일러 기법.
번역 후 실행.
효율적, 반복문 처리에 효과.
큰 기억장소 요구.
FORTRAN, COBOL, BASIC, PASCAL, C, C++, JAVA.

인터프리터 기법.
번역과 실행.
실행시간이 길다.
사용자와 대화식.
융통성.
LISP, APL, SNOBOL, Python.

컴파일러 번역과정.
프로그램 -> 어휘분석 -> 구문분석 -> 의미분석 -> 목적코드 생성( 어셈블리어, 기계어 )
프로그램 -> 어휘분석 -> 구문분석 -> 의미분석 -> 중간코드 -> 최적화 -> 목적코드 생성.

최적화.
중간코드에서 목적코드로 변환할 때 수행시간, 기억공간을 최소화하는 것.



 # 컴파일러 논리적구조.

논리적 구조 6단계.
어휘분석 -> 구문분석 -> 의미분석 -> 중간코드 -> 최적화 -> 목적코드 생성.

어휘분석.
기본어휘가 문법에 맞는지 분석.
어휘를 토큰으로 변환.
연산자, 식별자, 예약어, 구분자, 상수.
어휘분석 : Lexical Analysis, Scan.
어휘분석기 : Lexical Analyzer, Scanner.

구문분석.
구문이 문법에 맞는지 분석한다.
분석결과를 파스트리로 출력.
구문분석 : Syntax Analysis, Parse.
구문분석기 : Syntax Analyzer, Parser.
파스트리( 치환문 ) : 식별자 := 식 + 식 + 식 ...

의미분석.
파스트리에 의미부여.
실행 전 사전작업.
자료구조정의, 혼합형연산, 기호표.
ABC := E * 3.14 +ABC/E ;

중간코드.
최적화를 위한 중간단계.
후위표현.
3 주소코드. 
U 코드.
문법지시적변환.

최적화.
효율화.
수행시간 최소화.
기억공간 최소화.

목적코드 생성.
사용할 레지스터의 수.
계산과정.
명령어 종류.



 # 논리적구조/물리적 구조.

컴파일러의 논리적 구조와 물리적구조.
1패스 : 어휘분석, 구문분석, 의미분석, 중간코드.
2패스 : 최적화, 코드생성.

패스로 나누는 이유.
최적화 부분이 많아서 비율상 1,2패스로 나눔.
포팅하기 좋다.

1-패스 컴파일러. ( 옛날방식 )
한 번에 기계코드로 변환해서 효율적이다.
실행속도가 빠르다.
backpatching을 해야만 한다.

2-패스 컴파일러. 
이식성( Portability )가 뛰어나다.
기계독립적, 최적화가 뛰어나다.
기억장소를 절약할 수 있다.
기계코드 표현이 제약적이다. 
실행속도가 느리다.



 # 컴파일러 실행 예.

ABC := E * 3.14 + ABC / E ;
연산자우선순위 이용, 과정만 설명.

ABC := E * 3.14 + ABC / E 과정.
100 LOAD 201		150 3.14
101 MULT 150		...
102 STORE 160		...
103 LOAD 200		160 E * 3.14
104 DIV 201		...
105 ADD 160		200 ABC
106 STORE 200		201 E

연산에 필요한 것들.
기호표 : 변수와 상수를 저장하는 공간. ( ( 1또는2, 위치 ) - 변수는 1, 상수는 2로 표현 )
피연산자 stack : 피연산자를 저장하는 stack 공간.
연산자 stack : 연산자를 저장하는 stack 공간.




