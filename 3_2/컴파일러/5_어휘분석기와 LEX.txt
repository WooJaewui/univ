
 어휘분석기와 LEX.



 # 어휘분석기 설계.

어휘분석.
원시프로그램을 읽어 들여 토큰이라는 의미 있는 문법 단위로 분리하는 것.
정규문법이 주어지고 문법단위에 대한 토큰표를 작성한 후 DFA를 작성한다.
정규문법 -> 정규표현 -> 유한오토마타 -> 어휘분석기. ( 유한오토마타 구현 )

어휘분석.
하나하나가 올바른지 확인한 후에 올바르면 토큰으로 변경해준다.

토큰 예시.
( 1, 0 ) : 1은 자기자신( 변수, 상수 )을 의미하고, 0은 위치를 의미한다.

토큰의 종류.
식별자 : 프로그래머가 정의하는 변수 이름. ( ABC, E, ... )
상수 : 정수, 실수, 문자형 상수. ( 100, 3.14, "abc", ... )
예약어 : 구현시 이미 정의된 지정어. ( DO, IF, while )
연산자 : +, -, *, / 등.
구분자 : 단어를 구분하는 기호. ( [ , ( , ; , : ) 

토큰표.
토큰의 정보를 나타낸 표. ( 토큰이름, 토큰번호, 토큰값으로 이루어짐 )



 # 어휘분석기 구현.

어휘분석기 구현 고려사항.
문법이 명확히 정의되어야 한다.
상태전이도( DFA ) 순서가 중요하다 - 많이 사용되는 토큰을 구별해야됨. ( 확률개념 )
구문분석기와 어휘분석기의 호출순서.
실수의 내부표현 문제.
문자 검조 시간 단축 문제.

컴파일러 구현.
언어와 목적기계( 하드웨어 )가 발달할수록 많은 컴파일러가 필요하다.
예 : N개의 언어를 M개의 컴퓨터에서 구현하려면 N*M개의 컴파일러가 필요하다.

어휘분석기 생성기 종류. ( Scanner )
LEX, FLEX, ScanGen, PCLEX, JLEX.



 # LEX의 기능.

LEX의 어휘분석 과정.
정규표현( 파일이름.L )  -> LEX -> 어휘분석용 소스프로그램 ( lex.yy.c ) -> 컴파일 -> 어휘분석기.
원시프로그램 -> LEX 어휘분석기 -> 일련의 토크.

LEX의 형식.
{ 정의부분 }  
{ 규칙 부분 } 
{ 사용자 부프로그램 } 

정의부분의 예.
%{ 
	#include <stdio.h>
	%include <stdlib.h>
	enum tnumber { TEOF, TIDEN, TNUM , ... } ;
%} 
letter [a-zA-Z]
digit [0-9]

규칙부분 예.
begin
end
{ letter }( { letter } | { digit } ) ***
....

사용자 부프로그램.
%%
C언어로 코딩.

문자들의 classes 정의.
-( dash ) : 구간 표시 ( 예 : [a-z0-9] )
^( hat ) : negate 또는 complement. ( 예 : [^a-z] ) 
\( backslash ) : escapte.
a*** : a를 0번 이상. ( 앱실론 포함 )
a**+ : a를 1번 이상. ( 앱실론 X )

LEX 수행코드.
정규표현이 매칭되면 즉, 토큰이 인식되었을 때 실행해야 할 행동을 C언어로 기술하는 부분.

수행코드 구성.
전역변수, 함수, I/O 루틴. 

전역변수.
yytext : 정규표현과 매칭된 실제 문자열 보관 변수. 
yyleng : 매칭된 문자열의 길이를 저장하는 변수. ( 토큰의 길이 )



 # LED 실행절차.

실행절차.
LEX명세 ( test.L ) -> LEX -> test.c( 원시코드 ) -> Compiler VC++( 라이브러리 추가 ) -> test.exe

PC에서 실행.
cmd > PCL32 -i test.l
cmd > 컴파일( C언어 ) text.c 
cmd -> TEST <= data1.
출력결과 >1( 줄개수 ), 7( 단어개수 ), 39( char숫자 - 사이띄기 포함 )





