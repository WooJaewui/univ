
 코드의 최적화와 코드의 생성.



 # 실행시간의 최적화.

공통 부분식 제거 common subexpression.
A := B + C + D ;
E := B + C + F ;
------- 최적화 ---------
T := B + C ;
A := T + D ;
E := T + F ;

상수전파 constant propagation.
컴파일 시에  상수를 포함하는 연산을 계산함.
X := 3.14 ;
Y := 2 * X ;
------- 최적화 ------
Y := 6.28 ;

코드이동 code motion.
루프불변코드를 루프 바로 전위치로 이동.
i := 0 ;
i++ ;
T := 4 * i ;
------ 최적화 ------
T := T + 4 ;

루프의 융합 loop fusion.
여러 개의 루프를 하나의 루프로 만드는 것.
for i := 1 to 100
A[ i ] := 10 ;
for j := 1 to 100
B[ j ] := 20 ;
-------- 최적화 ---------
for o := 1 to 100
A[ i ] := 10 ;
B[ i ] := 20 ;

루프 전개 loop unrolling.
조건부 분기명령의 경우 효과가 반감될 수 있다. ( Store가 여러번 생김 )
for i := 1 to 100
A[ i ] := 10 ;
------------ 최적화 ------------
for i := 1 to 100
A [ i ] := 10 ;
i++ ;
A [ i ] := 10 ;

프로시저 호출의 전개.
프로시저를 호출하는 곳에서 호출되는 프로시저의 본체를 전개.
매개변수로 값을 줄 때, 매개변수에 대한 조건을 작성하지 않는다.

불필요한 코드의 제거.
도달 불가능한 코드 제거.

복사전파 copy propagation.
A := B
C := A + D 
------------- 최적화 --------------
C := B + D 

식의 연산순서 변경 rearranging expression.
A * B - C * D 
A * B STORE 1
C * D STORE 2
STORE 1 - STORE 2 ( STORE 2개 사용 )
------------- 최적화 -------------
C * D - A * B 
C * D STORE 1
A * B - STORE 1 ( STORE 1개 사용 )

제어흐름의 최적화.
goto L1
L1 : goto L2
------------- 최적화 -------------
goto L2
L1 : goto L2

연산의 세기 경감.
X ** 2 
X * 2
------------- 최적화 -------------
X * X
X + X



 # 기억용량의 최적화.

기억용령의 최적화.
상수전파, 루프의 융합, 복사전파, 중복된 로드, 저장 명령문 등 실행 최적화와 같은 것들이 있다.

부프로그램화.
같은 패턴이 여러 번 나타나면 부프로그램으로 구성.

부분식 끌어올리기.
같은 식의 연산이 여러 군데 있으면 하나의 연산식을 블록 앞으로 가져옴.

최적화의 구현.
여러 방법들 중에 우선순위 적용. - 상황에 따라 다르다 
각각의 방법들의 적용방법 - 사람들의 취향에 맞게 자신의 방법으로 구현.



 # 목적 코드 생성.

목적 코드 생성.
고급언어 -> 컴파일러 -> 저급언어.

컴파일러.
어휘분석 -> 구문분석 -> 의미분석 -> 중간코드 -> 최적화 -> 목적 코드 생성.

코드의 생성시 고려사항.
어떤 명령어를 선택할 것인가 - 같은 연산자에 다양한 명령어 존재.
계산과정을 어떤 순서로 할 것인가 - 연산레지스터 개수와 기억장소 크기 등에 영향.
피연산자를 연산레지스터에 어떻게 배정할 것인가 - 가능하면 연산레지스터를 많이 사용.



 # 산술식의 목적코드 생성.

traversal.
트리구조에서 어느부분을 먼저 찾아갈 것인지 결정하는 것.

연산 레지스터가 한 개인 경우.
트리구조를 사용한다.
데이터 레지스터에 임시저장해서 연산한 후 연산 결과값을 저장장소에 저장해서 연산한다.

레지스터가 복수개인 경우.
데이터를 레지스터에 저장해서 연산한 후 연산 결과값을 레지스터에 저장한다.

레지스터의 숫자가 제한적인 경우.
최대한 레지스터 공간을 사용하고 넘었을 경우 저장장소에 저장해서 연산한다.
( 레지스터가 성능이 좋기 때문에 최대한 많이 사용한다 )



 # 논리식의 목적코드 생성.

논리식의 목적코드 형태.
if e then goto L 형태로 바뀐다.
true이면 L로 가고, false인 경우 아래에 문법을 작성해준다.
3주소 코드 표시 : T( e, t, L )

기호.
∧ : and를 의미한다.
∨ : or를 의미한다.



