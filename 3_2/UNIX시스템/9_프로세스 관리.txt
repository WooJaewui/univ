
 프로세스 관리.



 # 프로세스.

프로세스 정의.
커널에 등록되어 관리를 받는 작업 또는 실행 중인 프로그램.
커널은 프로세스 관리 블록( PCB )에 프로세스에 관한 정보를 저장.
프로세스는 시스템 자원을 사용하며 여러 상태 변화를 겪음.
각 프로세스는 유일한 PID를 가짐.

프로세스 예.
init 프로세스 PID가 1. ( 모든 사용자 프로세스의 조상 ) 
로그인 하거나 터미날 창을 열면 'bash 프로세스'가 할당됨.
필요에 따라 프로세스는 자식 프로세스를 생성함.
데몬 프로세스는 서비스 요청을 처리하기 위한 백그라운드 프로세스.

프로세스 관리 블록. ( PCB )
커널에 등록된 각 프로세스에 대한 정보를 저장하는 영역.
프로세스들은 모두 커널 공간에 자신의 정보를 가짐.

PCB에 저장되는 정보.
PID와 PPID. ( Process ID와 Parent Process ID )
UID와 EUID 및 GID와 EGID.
프로세스의 현재 상태 실행 / 준비 / 보류 / 지연 등의 상태 정보와 CPU 사용 시간 등.
프로세스 우선순위.
프로세스가 사용 중인 자원에 관한 정보.
메모리 주소, 입출력 장치, 파일 등.
모든 대기 중인 시그널의 목록.
문맥 교환 정보.

명령의 실행과 프로세스 생성.
셸에서 명령을 실행하면 새로운 프로세스가 만들어져 처리됨.
시스템 호출 fork( )를 호출하여 기존 부모 프로세스가 자신의 복사본 자식 프로세스를 만듦.
자식 프로세스는 시스템 호출 exec( program )에 의해 새로운 프로그램으로 대체되어 실행됨.
프로그램이 종료되면 자식 프로세스가 종료됨.
부모 프로세스는 보류 상태에 있다가 자식 프로세스가 종료되면서 깨어남.
pstree : 프로세스 트리를 보여주는 명령.

프로세스 생성 예.
터미널 창에서 ls 명령을 실행하면
셸은 fork( )를 호출하여 셸의 복사본( 자식 프로세스 )를 생성함.
자식 프로세스는 exec( ls )를 호출하여 ls 명령을 실행함.

포어그라운드( foreground ) 프로세스.
쉘 프롬프트에서 명령을 실행하면 foreground 모드로 수행됨.
foreground 프로세스가 끝나기 전에는 다른 명령을 수행할 수 없음.
foreground 프로세스는 터미널에 대한 제어권을 가짐.
foreground 프로세스는 키보드 입력 및 화면 출력이 가능함.
터미널로부터 키보드 입력을 받을 수 있는 프로세스는 하나 뿐임.
Ctrl + C : foreground로 실행 중인 프로세스를 강제 중지.
Ctrl + Z : foreground로 실행 중일 경우 백그라운드로 전환되며 멈춤( 또는 지연 ) 상태가 됨.

백그라운드( background ) 프로세스.
백그라운드로 실행하려면 쉘 프롬프트에서 명령의 끝에 &를 추가하여 실행함.
백그라운드로 프로세스를 실행시키면 쉘은 즉시 명령 대기 상태가 됨.
백그라운드 프로세스는 터미널 출력은 가능하나 키보드 입력을 받을 수 없음.
백그라운드 프로세스가 키보드 입력이 필요하면 지연 상태가 됨.
입력 없이 장시간 실행되어야 하는 경우 주로 사용.
터미널 창을 종료하면 연결된 모든 백그라운드 프로세스도 종료됨.
fg jobid : 백그라운드를 포어그라운드로 전환하는 방법
jobs : 백그라운드 프로세스의 상태를 점검하는 명령. ( jobs -I : PID를 함께 보여줌 )

SetUID.
파일의 접근권한에서 소유자의 실행 권한에 x가 아닌 s가 표시됨.
실행 파일에 SetUID가 설정되면, 파일이 실행될 때 '실행시킨 사용자'가 아닌 파일의 소유자 권한으로 실행.
일반 사용자가 passwd 명령으로 비밀번호를 수정하려면 권한 상승이 필요하다.
( 비밀번호 변경은 /etc/passwd 또는 /etc/shadow 파일의 수정이 필요함 )

SetUID 설정.
설정 방법 : chmod 4755 file 또는 chmod u+s file.
해제 방법 : chmod 0775 file 또는 chmod u-s file.

SetGID.
파일의 접근권한에서 그룹의 실행 권한에 s가 표시됨.
SetGID가 설정된 파일을 실행하면 '실행자의 그룹 권한이' 아닌 '파일 소유자의 그룹 권한'으로 실행.
디렉토리에 설정된 경우, 디렉토리에 파일을 만들 때 '파일의 소유 그룹'이 '디렉토리의 소유 그룹'으로 지정.

SetGID 설정.
설정 방법 : chmod 2755 file 또는 chmod g+s file.

StickyBit.
파일의 접근권한에서 기타 사용자의 실행 권한에 t가 표시됨.
주로 공유 디렉토리에 설정되며, 누구나 디렉토리에 파일 생성할 수 있지만 파일의 소유자만 삭제할 수 있음.

StickyBit 설정.
설정 방법 : chmod 1755 file 또는 chmod o+t file.



 # 프로세스의 상태.

프로세스의 상태 변화.
제한된 자원과 멀티 태스킹을 지원하는 운영체제에서 프로세스는 여러 상태 변화를 겪음.

상태.
fork( ) -> 생성 -> load -> 준비 -> 디스패치 -> 실행 -> 종료.

ps 명령.
현재 프로세스의 상태를 확인하는 명령.
특정 순간에 활동 중인 프로세스의 상태를 보여줌.

ps [options]
옵션 없이 ps명령을 실행하면 현재 터미널과 연결되어 있는 프로세스 중 
프로세스의 EUID가 현재 사용자의 UID와 같은 프로세스를 선택하여 보여줌.
ps -e : 모든 프로세스. ( every )
ps a : 모든 사용자의 모든 프로세스를 출력.
ps -ef : 모든 프로세스의 식별 정보를 더 잘 보여줌.
ps aux : 모든 프로세스의 상태 정보를 더 잘 보여줌.



 # 프로세스 관리.

top 명령.
현재 실행 중인 프로세스의 모니터링과 관리를 위한 대화식 도구.
현재 실행 중인 개별 프로세스의 실시간 정보를 주기적으로 보여줌.
CPU와 메모리 사용량 및 시스템의 부하 등을 확인.
ps 명령의 동적 / 대화식 버전.

top [options].
-p delay : 초 단위로 주기를 지정.
-p pids, -u user : 특정 프로세스나 사용자 프로세스로 한정.
-S : 총 CPU 사용 시간( 자식 프로세스 포함 )을 출력.

top 명령 사용.
기본적으로 CPU 사용량이 많은 프로세스를 먼저 보여줌.
top 명령에서 헤더의 의미는 ps 명령과 유사함. ( 교재 표 9-3, 9-4 참조 )

top 명령 - 대화식 서브 명령.
space bar : 화면을 갱신함.
kill : kill 명령을 수행. ( 시그널을 보냄 )
r : renice 명령을 수행. ( 우선순위 바꾸기 )
u : 명령 옵션에서 -u의 의미와 같음. 
m : %MEM 값으로 정렬.

kill 명령.
프로세스에 시그널을 보내는 명령.
다른 프로세스에게 시그널을 보내도록 커널에게 요청하는 것.
시그널은 프로세스 관리 방법이 고 프로세스 간 통신 수단.
여러 종류의 시그널이 존재하며 기본 시그널은 TERM임. ( 15 )

Kill [-sigmal] pids.
signal은 시그널의 이름 또는 시그널 번호.
kill pids 명령은 TERM 시그널을 보냄.
kill -STOP 3188은 해당 PID를 가진 프로세스에게 멈춤 시그널을 보냄.

killall [options] [-s signal] [-u user] names.
특정 프로세스에 한꺼번에 시그널을 보내는 명령.
killall -i -s 9 -u kdhong bash : 확인을 거쳐 kdhong 계정의 bash 프로세스에게 -s 9 시그널을 보냄.
-s 9 : 강제 종료를 의미.

시그널의 종류.
HUP(1) : - 터미널이 종료될 때 터미널에 연결된 모든 프로세스에게 보내짐. 
           - 데몬 프로세스가 설정 파일을 다시 읽어 재시작하게 만들 때 사용하는 시그널.
INT(2) : Interrupt의 의미로 터미널에서 Ctrl+C를 누르는 것과 같음.
KILL(9) : kill의 의미로 프로세스를 강제로 즉시 종료시킴.
TERM(15) : Terminate의 의미로 kill 명령의 기본 시그널. 정상적인 종료 방법으로 끝내게 함.
CONT(18) : Continue의 의미로 STOP 시그널로 중단되 프로세스를 재개시킴.
STOP(19) : STOP의 의미로 프로세스를 잠시 중단시킴.
TSTP(20) : Terminal Stop의 의미로 터미널에서 Ctrl + z를 누르는 것과 같음.

nice와 renice 명령.
nice 우선순위( NI ) 값을 조정하는 명령.
NI 값은 -20( 가장 높음 ) ~ 19( 가장 낮음 ) - 기본 NI 값은 0이다
우선순위가 높으면 CPU를 점유할 확률이 높음.  

nice [option] [command ]
명령을 실행할 때 NI 값을 조정하는 명령.
일반 사용자는 NI 값을 0 이상으로만 지정할 수 있음.
-n adjustment : 조정 수치 만큼 NI 값을 조정.
nice -n +5 top : NI값을 5증가 시켜 우선순위를 낮춤.

renice priority [options]
실행 중인 프로세스의 NI값( 절대값 )을 바꾸는 명령.
일반 사용자는 자신이 소유한 프로세스의 우선순위를 낮출 수만 있음.
-p pids : 프로세스를 지정.
-g gids : GID를 지정.
-u users : 사용자를 지정.
renice 10 -u jjpark : jjpark 계정이 소유한 모든 프로세스의 NI 값을 10으로 조정.

nohup 명령.
HUP 시그널과 무관하게 명령이 스스로 종료될 때까지 계속 수행시키는 명령.
로그아웃을 하거나 터미널 창을 끝내면 프로세스에 HUP 시그널이 보내짐.
nohup 명령을 실행하는 경우 명령 행의 끝에 '&'를 붙여 백그라운드로 실행해야 함.
예 : nohup find -size + 100k > log.txt &

프로세스 관리를 위한 GUI.
데스크톱 메뉴에서 '프로그램 > 시스템 도구 > 시스템 정보'를 실행.
시스템 정보 창에서 모든 또는 자신이 소유한 프로세스의 상태를 보고 [편집]메뉴에서 상태를 제어할 수 있다.



 # cron 서비스.

cron 서비스.
지정된 시간에 주기적으로 자동 수행되는 작업을 수행함.
crond 데몬 프로그램이 서비스를 제공.
1분 간격으로 'contab 파일' 을 검사하여 수행함.
'crontab 파일' 에는 'cron 작업의 수행 방법' 이 기록되어 있ㅇ므.
일반적으로 'cron 작업' 은 셸 스크립트로 작성됨.

cron 서비스를 이용한 자동 스케쥴.
/etc/crontab 파일과 /etc/cron.d/ 디렉토리에 존재하는 파일.
시스템 수준에서 주기적으로 수행될 작업을 설정.
개별 사용자는 crontab 명령을 이용하여 주기적으로 수행될 작업을 설정할 수 있다.

crontab 파일의 형식.
환경 변수의 설정과 cron 작업의 수행 방법을 정의.
분, 시, 날짜, 달, 요일의 순서로 표시. ( 매번 * , 간격 표시 / , 범위 표시 - , ) 
사용자는 시스템 수준 crontab 파일의 경우에만 지정.
실행할 명령.
예 : 01 * * * * root run-parts /etc/cron.hourly
예 : 0 */8 * * 1-5 /bin/mail -s "Hi" jjpark@localhost - 월~금요일까지 0,6,12,18시에 메일을 보냄.

일반 사용자 contab 명령.
일반 사용자가 자신의 cron 작ㅂ업을, 자신의 crontab 파일에 등록할 때 사용해야 하는 명령.

crontab [options].
-l : crontab 파일의 내용을 출력함.
-e : crontab 파일을 vi로 편집할 수 있음.
-r : crontab 파일을 삭제함.
-u user : 지정된 사용자의 crontab 파일을 사용함. ( 권한이 필요 )
지정된 시간에 일회성으로 작업을 예약하려면 at을 사용.



