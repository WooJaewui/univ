 
 컴퓨터 명령어.



 # 명령어.

명령어 형식의 분류.
오퍼랜드의 기억장소에 따른 명령어 형식. 
오퍼랜드의 수에 따른 명령어 형식.



 # 기억장소에 따른 명령어 형식.

종류.
누산기를 이용하는 명령어 형식.
다중 레지스터를 이용하는 명령어 형식.
스택 구조를 이용하는 명령어 형식.

누산기 AC accumulator. 
누산기를 가진 컴퓨터 구조에서 중앙처리장치에 있는 유일한 데이터 레지스터.
명령어가 수행될 때 오퍼랜드를 기억시키는 레지스터이다.
ACC로 불리기도한다.

레지스터 종류.
범용레지스터 : 일반적인 레지스터.
특수용도레지스터 : AC, stackpointer 등.

누산기를 이용하는 명령어 형식.
누산기를 가진 컴퓨터 구조에서 사용되는 형식.
누산기 오퍼랜드와 X 오퍼랜드를 사용해서 명령어를 ALU에서 실행한다.
예 - ADD X ; AC <- AC + M[X].
예 - LOAD X ; AC <- M[X].
예 - STORE X ; M[X] <- AC.

다중 레지스터를 이용하는 명령어 형식.
다중 레지스터 컴퓨터 구조는 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터이다.
레지스터 오퍼랜드를 사용해서 명령어를 ALU에서 실행한다.
예 - ADD R1,R2,R3 ; R3 <- R1 + R2 ( 왼쪽 연산, 오른쪽 연산은 컴퓨터마다 다르게 약속되어 있다 )
예 - ADD R1,R2 ; R2 <- R1 + R2 

누산기와 다중 레지스터를 구분방법.
연산을 위해 operand에서 n개의 데이터 필요한데, 
n-1개의 데이터가 있으면 묵시적으로 누산기를 사용했음으로 이해.

스택 구조를 이용하는 명령어 형식.
스택 구조 컴퓨터는 연산에 필요한 오퍼랜드들을 기억장치 스택에 기억시키야 하고, 
연산의 결과도 스택에 기억시키는 구조이다.
TOS TopOfStack : 스택의 맨 위.
SP StackPointer : TOS의 주소정보를 저장하고 있다.
예 - ADD ; TOS <- TOS + TOS-1
예 - PUSH X ; TOS <- M[X]
예 - POP X ; M[X] <- TOS



 # 오퍼랜드의 수에 따른 명령어 형식.

종류.
3-주소 명령어.
2-주소 명령어. 
1-주소 명령어. 
0-주소 명령어. 

3-주소 명령어.
명령어 오퍼랜드의 개수가 세 개인 명령어 형식.
장점 : 산술식을 프로그램화하는데 있어서 프로그램의 길이가 짧아짐.
단점 : 2진 코드화 했을 때 세 개의 오퍼랜드를 나타내기 위한 비트 수가 많이 필요하다.

예시 X = ( A+B ) x C.
ADD A,B,R1 ; R1 <- M(A) + M(B)
MUL R1,C,X ; M(X) <- R1 x M(C)

2-주소 명령어.
명령어 오퍼랜드의 개수가 두 개인 명령어 형식.
장점 : 3-주소 명령어에 비해 명령어의 길이는 짧아짐. ( 비트의 수가 줄어듬 )
단점 : 같은 내용을 수행하기 위해 수행해야 하는 명령어의 수가 증가됨.

예시 X = ( A+B ) x C.
LOAD A, R1 ; R1 <- M(A).
ADD B, R1 ; R1 <- R1 + M(A).
MUL C, R1 ; R1 <- R1 x M(C).
STORED R1, X ; M(X) <- R1.

1-주소 명령어.
명령어 오퍼랜드의 개수가 두 개인 명령어 형식.
장점 : 모든 연산은 누산기 레지스터와 기억장치에 저장된 오퍼랜드를 대상으로 수행.
단점 : 프로그램을 수행하기 위해 사용되는 명령어의 수는 더 증가.

예시 X = ( A+B ) x C.
LOAD A ; AC <- M(A)
ADD B ; AC <- AC + M(B)
STORE ; M(X) <- AC
LOAD C ; AC <- M(C)
MUL X ; AC <- AC X M(X)
STORE X ; M(X) <- AC

0-주소 명령어.
명령어 오퍼랜드의 개수가 없는 형식.
장점 : 명령어의 길이가 매우 짧아서 기억공간을 적게 차지.
단점 : 특수한 경우를 제외하고는 많은 양의 정보가 스택과 기억장치 사이를 이동해서 비효율적.

예시 X = ( A+B ) x C.
PUSH A ; TOS <- M(A)
PUSH B ; TOS <- M(B)
ADD ; TOS <- TOS + TOS-1
PUSH C ; TOS <- M(C)
MUL ; TOS <- TOS x TOS-1
POP X ; M(X) <- TOS 

정리.
명령어의 수가 많아지면 그만큼 ALU에서 많은 양을 처리해야되서 연산속도가 느려질 수 있다.
오퍼랜드의 수가 많아지면 차지하는 비트 수가 많아져서 메모리 공간이 부족할 수 있다.



 # 주소지정방식.

명령어 주소지정방식 addressing mode.
프로그램 수행 시 오퍼랜드를 지정하는 방식.
명령어의 주소 필드를 변경하거나 해석하는 규칙을 지정하는 형식.
주소지정방식을 사용하면 명령어의 수를 줄일 수 있는 효과적인 프로그래밍 가능.

유효주소.
주소지정방식의 각 규칙에 의해 정해지는 오퍼랜드의 실제 주소.

주소지정방식 필드를 가진 명령어 형식.
연산코드( OP-CODE ) + 주소지정방식( MOD ) + 주소 혹은 오퍼랜드( Operand ) 
연산코드 : 수행할 연산의 종류를 지정.
주소지정방식 : 연산에 필요한 오퍼랜드의 주소를 알아내는 데 사용.
주소 혹은 오퍼랜드 : 기억장치주소 혹은 레지스터를 나타낸다.



 # 주소 지정방식의 종류.

의미주소지정방식 implied mode.
명령어 형식에서 주소 필드를 필요로 하지 않는 방식.
예 - ADD ; TOS <- TOS + TOS-1

즉치 주소지정방식 immediate mode.
명령어 자체 내에 오퍼랜드를 지정하고 있는 방식.
오퍼랜드 필드의 내용이 실제 사용될 데이터.
예 - LDI 100, R1 ; R1 <- 100

직접 주소지정방식 direct-addressing mode.
명령어의 주소필드에 직접 오퍼랜드의 주소를 저장시키는 방식.
기억장치에의 접근이 한번에 이루어짐.
예 - LDA ADRS ; AC <- M[ADRS]

간접 주소지정방식 indirect-addressing mode.
명령어의 주소필드에 유효주소가 저장되어있는 기억장치 주소를 기억시키는 방식.
예 - LDA [ADRS] ; AC <- M[M[ARDS]] 

레지스터 주소지정방식 register mode.
오퍼랜드 필드에 레지스터가 기억되는 방식.
레지스터에 오퍼랜드가 들어있음. ( 유효주소가 없음 )
예 - LDA R1 ; AC <- R1

레지스터 간접 주소지정방식 register-indirect mode.
레지스터가 실제 오퍼랜드가 저장된 기억장치의 주소 값을 갖고 있는 방식.
예 - LDA (R1) ; AC <- M[R1]

상대 주소지정방식 relative addressing mode.
유효주소를 계산하기 위해 처리장치 내에 있는 특정 레지스터의 내용에 값을 더하는 방식.
특정 레지스터로 프로그램 카운터( PC )가 주소 사용.
유효주소 =  명령어 주소부분의 내용 + PC의 내용.
예 - LDA $ADRS ; AC <- M[ADRS + PC] 

인덱스된 주소지정방식 indexed addressing mode.
인덱스 레지스터의 내용을 명령어 주소 부분에 더해서 유효주소를 얻는 방식.
유효주소 = 명령어 주소부분의 내용 + 인덱스 레지스터의 내용.
예 - LDA ADRS(R1) ; AC <- M[ADRS+R1]



 # 명령어의 종류.

데이터 전송 명령어.
한 장소에서 다른 장소로 단지 데이터를 전송하는 명령어.
입출력 명령어가 포함.
Load LD, Store ST, Move MOVE, Exchange XCH, Push PUSH, Pop POP 등.

데이터 처리 명령어.
산술 명령어 : 데이터에 대한 연산을 실행하고 컴퓨터에 계산능력을 제공.
논리와 비트 처리 명령어 : 레지스터나 기억장치에 저장된 단어에 대한 2진 연산.
시프트 명령어 : 오퍼랜드의 비트를 왼쪽이나 오른쪽으로 이동시키는 명령어.

프로그램 제어 명령어.
프로그램 수행의 흐름을 제어.
다른 프로그램의 세그먼트로 분기.



