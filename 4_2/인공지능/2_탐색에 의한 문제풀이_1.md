# 탐색에 의한 문제풀이_1

--------------------------------------------------------------------------------------------------------

> ## 문제풀이의 개념.

### 문제풀이.
- 직관적으로 단순하게 해결할 수 없는 문제에 대해 문제를 파악하고 문제의 해에 이르는 방법을 찾아내는 일련의 과정.

### 문제풀이에 사용될 수 있는 전략.
- 알고리즘.
- 시행착오 : 알고리즘으로 적용하기 어려운 경우 사용. (많은 비용이 발생할 수 있다)
- 경험적 방법 : 시행착오를 좀 더 효과적으로 사용할 수 있도록 도와준다.
- 통찰 : 문제를 이해하고 해결 방법을 찾는 것.

### 8-퍼즐 문제의 풀이.
- 퍼즐 조각의 배치나 조각의 이동 방식 등을 컴퓨터로 표현.
- 여러 가지 방향으로 조각을 이동하는 것을 시도하는 과정에서 시행착오를 거쳐 문제 해결.

### 8-퍼즐 문제 예시.
- 상태 (state) : 퍼즐 판에 나열된 퍼즐 조각 배치 형태.
  - 초기상태 : 최초에 주어진 문제의 상태.
  - 목표상태 : 풀이된 결과에 해당되는 문제의 상태.
- 상태 묘사 (state description) : 적절한 자료구조를 이용하여 컴퓨터를 통해 상태를 표현.
- 연산자 (operator)상태를 변화시키기 위한 도구의 표현.

### 상태 묘사.
- 풀이하고자 하는 문제의 상태를 컴퓨터로 처리하기 위한 적절한 자료구조로 표현한 것.
- 문제에 따라 적절한 자료구조를 선택.
  - 문제의 상태를 표현하는데 보다 자연스러운 표현 방법.
  - 하나의 상태묘사에서 다른 상태묘사로 변화시키는 연산이 용이한 표현.
    - 기호 열, 벡터, 다차원 배열, 트리, 리스트 등.

### 연산자.
- 어느 한 상태로부터 변화할 수 있는 다른 상태로 변환함.
- 연산자 정의.
  - 변환 테이블을 정의하는 방법.
    - 모든 입력 상태묘사에 대해 각각의 상태로부터 변화할 수 있는 모든 출력 상태묘사를 저장하는 목록을 만듦.
  - 일반화된 변환 규칙으로 정의하는 방법.
    - 하나의 상태묘사를 다른 상태묘사로 변화시키는 일종의 연산 능력을 지닌 함수로 정의.

### 상태 사이의 관계 표현.
- 방향성 그래프를 이용하여 부모상태와 후계상태의 관계를 표현.

### 상태 공간.
- 정의된 연산자 집합을 이용하여 초기상태로부터 얻을 수 있는 모든 상태의 집합.

### 상태 공간에서 문제풀이를 위한 문제의 표현.
1. 상태묘사 및 초기상태 정의.
2. 연산자 정의.
3. 목표상태 정의.

--------------------------------------------------------------------------------------------------------

> ## 상태공간 탐색에 의한 문제풀이.

### 상태공간에서의 문제 풀이.
- 초기상태에서 시작하여 목표상태에 도달할 수 있는 일련의 연산자를 찾는 것.
- 그래프에서 경로의 탐색 문제.
- 시행착오를 거치면서 목표상태에 도달하는 탐색 과정.
- 탐색에 유용한 지식을 사용함으로써 방대한 상태공간에서 탐색 범위를 좁히려고 함.

### 탐색 과정.
- 정해진 기준에 따라 노드를 선택.
- 선택된 노드에 적용할 수 있는 모든 연산자를 가하여 모든 후계노드를 생성. (노드확장)
- 후계노드에 부모노드를 가리키는 포인터를 첨부.
  - 탐색에 성공한 후 풀이 경로를 알 수 있게 함.
- 목표노드가 있는지 검사함.
- 원하는 목표를 찾지 못했다면 정해진 기준에 따라 다음 노드를 선택하여 탐색 과정 반복.
- OPEN : 앞으로 확장할 노드를 저장하는 리스트.
- CLOSED : 이미 확장한 노드를 저장하는 리스트.
- 탐색 알고리즘에 따라 정해진 순서로 OPEN에서 확장할 노드를 꺼내 CLOSED로 옮김.
- 확장 결과 생성된 노드를 OPEN의 적절한 위치에 저장함.

### 탐색 방법의 종류.
- 맹목적 탐색 blind search.
  - 목표노드의 위치와 무관한 순서로 노드 확장.
  - 매우 소모적인 탐색을 할 가능성이 높음.
- 경험적 탐색 heuristic search.
  - 문제영역에서 사용할 수 있는 목표노드의 위치와 관련된 경험적 정보를 사용.
  - 경험적 정보 : 항상 옳은 것은 아니지만, 개연성이 있어 많은 경우 잘 맞는 정보.

### 탐색의 목적 및 경험적 정보 사용에 따른 분류.
- 맹목적 탐색.
  - 임의 경로 탐색 : 깊이우선 탐색, 너비우선 탐색.
  - 최적 경로 탐색 : 균일비용 탐색.
- 경험적 탐색.
  - 임의 경로 탐색 : 언덕오르기 탐색, 최적우선 탐색, 모의 담금질.
  - 최적 경로 탐색 : A* 알고리즘.

--------------------------------------------------------------------------------------------------------

> ## 깊이우선 탐색 및 너비우선 탐색.

### 깊이우선 탐색 depth-first search.
- 탐색 진행방향으로 계속 전진하여 목표를 탐색하는 방법.
- 가장 최근에 생성된 노드를 가장 먼저 확장함.
- OPEN은 스택 구조.
- 목표에 도달할 수 없는 경로를 계속 탐색하게 될 수 있음.
    - 깊이제한(depth bound)을 정할 수 있음.
- 깊이제한에 도달하거나 더 이상 진행할 경로가 없을 경우 이전 상태 중 다른 경로를 선택할 수 있는 위치로 복귀하여 탐색함.

### 너비우선 탐색 breadth-first search.
- 트리의 레벨 순서에 따라 노드를 확장함.
  - 생성된 순서에 따라 노드를 확장함.
  - OPEN은 큐.
- 만일 해가 존재한다면 출발노드에서 목표노드까지 도달하는 최단길이 경로를 찾는 것을 보장함.

--------------------------------------------------------------------------------------------------------

> ## 균일비용 탐색. (53분)

### 균일비용 탐색 uniform-cost search.
- 노드 사이의 경로비용.
  - 한 상태에서 다른 상태로 이동하기 위한 필요한 '비용'.
- 출발노드 S로부터 노드 n의 후계노드 ni까지의 경로비용.
  - g(ni) = g(n) + C(n,ni),i = 1,2,3, ... , m.
  - OPEN의 노드들 중 출발노드로부터의 경로비용이 최소인 노드를 선택하여 확장함.
  - 최소비용 경로를 탐색할 수 있음.
  - heap 자료구조를 통해 OPEN을 정렬해야 함.
  - 값이 같을 때는 아무거나 제거해도 된다.











