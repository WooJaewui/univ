# C++ 언어의 기초(2)

----------------------------------------------------------------------------------------------

> ## 흐름제어 구문.

### 기본적인 흐름제어 구조.
- 순차 구조.
  - 문장이 나열된 순서에 따라 차례로 실행하는 구조.
- 조건제어 구조.
  - 지정된 조건에 따라 실행 흐름을 제어하는 구조.
  - if문, switch문.
- 반복베어 구조.
  - 정해진 범위의 문장을 반복적으로 실행하게 하는 구조.
  - for문, while문, do ... while문.

### 조건문 - if.
    if(조건) {
        조건이 true일 때 실행할 문장;
    } else {
        조건이 false일 때 실행할 문장;
    }

### 조건문 - switch.
    switch(정수형_수식) {
        case 값1:
            정수형_수식이 값1일 때 실행할 문장;
            break;
        case 값2:
            정수형_수식이 값2일 때 실행할 문장;
            break;
        ...
        default :
            정수형_수식이 값에 매칭되는 것이 없을 때 실행할 문장;
    }

### 반복문 - 기본 for.
    for(초기화_문장; 반복조건; 증감_문장) {
        반복조건이 false일 때까지 반복할 문장;
    }

### 반복문 - 범위기반 for.
    for(원소선언 : 데이터집합) {
        데이터집합에서 원소 개수만큼 반복할 문장;
    }

### 반복문 - while.
    while(반복조건) {
        반복조건이 false일 때까지 반복할 문장;
    }

### 반복문 - do ... while.
    do {
        반복조건이 false일 때까지 반복할 문장; (무조건 1번 실행됨)
    }
    while(반복조건)

----------------------------------------------------------------------------------------------

> ## 구조체와 클래스.

### 구조체란?
- 여러 가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것.

### 구조체 선언문 형식.
    struct StructName {
        Type1 item1;
        Type2 item2;
        ...
    };

### 구조체의 예.
    // 중심좌표.
    struct C2dType {
        double x, y;
    };
    // 원.
    struct CircleType {
        C2dType center;
        double radius;
    };

### 구조체 데이터를 처리하는 함수.
    double circleArea(CircleType c) {
        return c.radius * c.radius * PI;
    }
    int main() {
        CircleType c1 = {{0,0} , 10}
        cout << " 원의 면적 : " 
             << circleArea(c1) << endl;
    }
- c 언어에서는 구조체와는 별개의 함수로 정의함.

### 클래스란 ?
- 표현하고자 하는 대상(객체)의 데이터(속성)와 함게 그 대상이 할 수 있는 동작을 나타내는 함수들을 묶어서 선언하는 것.
- C++ 에서의 클래스는 데이터 + 함수를 함께 묶어서 선언한다.

### 원 클래스 예시.
    class CircleClass {
        C2dType center;
        double radius;
        
        public:
            void init(double cs, double cy, double r) { ... }
            double area() const { ... }
            bool chkOverlap(const CircleClass& c) const { ... }
            void display() const { ... }
    }

### 클래스 활용 예제.
    int main() {
        CircleClass c1, c2;
        c1.init(0,0,10);
        c2.init(30,10,5);

        cout << "원1" << endl;
        c1.display();
        cout << " 원1의 면적 : " << c1.area() << endl;
        cout << " 원2 << endl;
        c2.display();
        cout << " 원2의 면적 : " << c2.area() << endl1 << endl;
        ...
    }

### C와 C++의 구조체 차이.
- C : 데이터만 가질 수 있다.
- C++ : 데이터와 함수를 모두 가질 수 있다.

----------------------------------------------------------------------------------------------

> ## 배열.

### 배열이란 ?
- 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것.
- 각각의 원소는 0번부터 시작하여 차례로 부여된 번호(첨자, 인덱스)를 이용하여 액세스 함.
- 배열의 차원 : 배열의 첨자 개수.

### 1차원 배열.
    float fArrary[4];
    int i=0;
    fArray[i] = 10.0f;
    cin >> fArray[1] >> fArray[2] >> fArray[3];
    cout << fArray[1] * fArray[2];

### 2차원 배열.
    int Arr2D[4][3] = { {1,2,3}, {4,5,6}, {7,8,9}, {10,11,12} }

### 여러 개의 데이터 중 최댓값 구하기.
    int main() {
        int max;
        int data[10] = { 10,23,5,9,22,48,12,10,55, 31 };

        max = data[0];
        cout << "데이터 : " << data[0];
        for( int i = 1; i<10; i++) {
            cout << " " << data[i];
            if(max<data[i]) {
                max = data[i];
            }
        }
    }

----------------------------------------------------------------------------------------------

> ## 포인터와 동적 메모리 할당.

### 포인터란 ?
- 어떠한 대상이 위치한 곳을 가리키는 변수.
  - 가리키는 대상은 포인터에 지정된 자료형에 해당되는 변수, 동적으로 할당된 메모리, 함수 등.
- 주의사항.
  - 포인터가 유효한 대상을 가리키게 한 후 사용해야 함.
  - &와 같이 주소 연산자를 활용.

### 포인터 선언 형식.
    /**  
     * TypeName : 가리킬 값의 자료형. 
     * ptrVar : 포인터 변수의 이름.
     */ 
    TypeName *ptrVar;
    ptrVar = &var;
    *ptrVar = value;

### 포인터의 활용.
    int main() {
      int a = 10;
      int* ptr;
      
      ptr = &a;
      cout << "ptr이 가리키는 값 : " << *ptr << endl;
      *ptr = 20;
      cout << "변수 a의 값 : " << a << endl;
      reutrn 0;
    }

### 동적 메모리 할당이란 ?
- 프로그램 동작 중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당하는 것.
  - 기억 공간의 생성 시점 : new 연산자의 실행 시점.
  - 기억 공간의 소멸 시점 : delete 연산자의 실행 시점.
- 포인터 변수가 할당된 기억 공간을 가리키게 함.

### 메모리 할당/반납 연산자.
    // 메모리 할당.
    ptrVar = new TypeName;
    ptrVar = new TypeName[n]
  
    // 메모리 반납.
    delete ptrVar;
    delete [] ptrVar;

### nullptr.
- 아무것도 가르키지 않는 포인터 상수.

### 배열 데이터 공간의 할당 및 반환.
    int * intPtr;
    intPtr = new int[4];
    *intPtr = 10;
    *(intPtr+1) = 20;
    intPtr[2] = 30;
    delete [] intPtr;
    intPtr = nullPtr;

----------------------------------------------------------------------------------------------

> ## 참조.

### 참조란 ?
- 어떠한 대상을 가리키는 값(포인터와 유사함)
- 참조 변수는 참조 대상의 별명처럼 사용할 수 있음.
- l-value 참조 : 실체가 있는 대상에 대한 참조.
- 참조는 반드시 초기화가 필요하다.
- 참조는 다른 대상을 참조하게 바꿀 수 없다.

### l-value 참조 변수의 선언 형식.
    TypeName& refVar = varName;

### l-value 참조 변수의 사용 예.
    int a = 10, b = 20;
    int& aRef = a;
    cout << aRef << endl;
    aRef = 100;
    aRef = b;

### const 참조.
- 참조 변수가 참조하는 대상의 값을 바꿀 수 없음.

### 참조가 포인터와 다른 점.
- 참조 변수를 이용하여 값을 읽거나 저장할 때 참조 대상 변수를 사용하는 형식과 동일함.
- 참조 변수는 초기화를 통해 반드시 어떤 대상을 참조해야 함.
  - 초기화되지 않은 상태로 인해 무엇을 참조하고 있는지 알 수 없는 상황은 발생하지 않음.
- 참조 변수는 초기화를 통해 지정된 참조 대상을 바꿀 수 없어 참조의 유효기간 동안 하나의 대상만 참조할 수 있음.

### r-value 참조란 ?
- 사용한 후에는 그 값을 더 이상 가지고 있을 필요가 없는 대상을 참조.

### r-value 참조의 용도.
- 객체의 값을 다른 객체로 이동.



