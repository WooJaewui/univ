
# 상속(2)

-------------------------------------------------------------------------------------

> ## 상속과 포인터.

### 클래스 게층구조와 포인터.
- 포인터(참조)로 가리킬 수 있는 대상.
  - 부모 타입의 변수에 자식 인스턴스를 담을 수 있다.
- 배열을 활용하면 자식, 부모를 같이 저장할 수 있다.

-------------------------------------------------------------------------------------

> ## 가상함수.

### 정적 연결 static binding.
- 컴파일 타임 타입과 런타임 타입이 같은 경우.
- 다형성을 사용하지 않은 일반적인 경우를 의미한다.

### 동적 연결 dynamic binding.
- 객체 포인터를 통해 객체의 멤버함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인가에 따라 실행 중에 멤버함수를 결정하는 것.
- C++ 에서는 가상함수 virtual function 로 동적 연결을 구현함.
- 기초 클래스에서 가상함수로 선언한 멤버함수를 재정의한 파생 클래스의 함수는 역시 가상함수이며, 동적 연결이 적용됨.

### 동적 연결로 동작하는 객체.
    class Person {
        ...
        virtual void print() const
            { cout << name; }
    };
- 자식 클래스에는 virtual을 생략할 수 있다.

### 소멸자의 동적 연결.
- 소멸자를 가상함수로 선언하지 않는다면 ?
  - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 기초 클래스의 소멸자만 동작함.
  - 파생 클래스의 소멸자가 동작하지 안항 필요한 작업이 누락됨.
- 소멸자를 가상함수로 선언.
  - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 파생 클래스의 소멸자가 동작할 수 있게 함.

### 소멸자를 가상함수 선언 예시.
    class BaseClass {
      int *ptB;
    public:
      ...
      virtual ~BaseClass()
        { ... }
    }
    class DrvClass : public BaseClass {
      ...
    public :
      ~DrvClass()
        { ... }
      ...
    }
- 자식 클래스에는 virtual 을 생략할 수 있다.
- 파생 클래스, 기초 클래스의 소멸자가 모두 동작.

### 업 캐스팅 upcasting.
- 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것.
- 묵시적 형 변환을 통해 업 캐스팅을 할 수 있음.
- 자식 타입을 부모 타입으로 변경함.

### 다운 캐스팅 downcasting.
- 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것.
- 묵시적 형 변환을 할 수 없으며, 형변환 연산자로 명시적 형변환을 해야 함.
- 부모 타입을 자식 타입으로 변경함.

### dynamic_cast.
- 런타임 시점에 자동으로 형변환하는 것을 의미한다.

### dynamic_cast 예시.
    Pserson *pPrsn1 = new Person( "Dudley" );
    Person *pPrsn2 = pStdnt1;
    Student *pStdnt2 = dynamic_cast<Student*>(pPrsn1);
- dynamic_cast 가 가리키는 대상이 형변환을 할 수 없는 경우 nullptr 을 반환함.

-------------------------------------------------------------------------------------

> ## 심화 학습.

### override.
- 가상함수의 재정의.
  - virtual 은 기초 클래스의 가상함수를 재정의할 때는 지정할 필요가 없으며, 파생 클래스에서 새롭게 가상함수를 선언하고자 할 때만 사용하는 것이 좋음.
  - 파생 클래스에서 어떤 함수가 가상함수인지 명확히 알기 어려울 수 있으므로, 가상함수를 재정의함을 명시적으로 알리고자 할 때는 'override'를 지정함.

### override 예시.
    class B : public A {
      ...
      void f() override { ... }
      ...
    };

### final.
- 가상함수의 재정의 금지.
  - 가상함수를 더 이상 재정의하지 못하게 하려면 final을 지정함.

### final 예시.
    class A {
      ...
      virtual void f() { ... }
      ...
    };
    
    class B : public A {
      ...
      void f final { ... }
      ... 
    };








