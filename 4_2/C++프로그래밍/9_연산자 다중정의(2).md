
# 연산자 다중정의(2)

------------------------------------------------------------------------------------------------------------

> ## 대입 및 이동 대입 연산자.

### 대입 연산자 =.
- 묵시적인 대입 연산자.
  - 우측 피연산자 데이터 멤버를 좌측 피연산자에 그대로 복사함.
  - 객체에 동적 할당된 메모리를 가리키는 포인터가 포함되어 있을 경우 얕은 복사로 인해 의도하지 않은 공유 상태의 문제가 발생할 수 있음.
  - 깊은 복사를 할 수 있는 대입 연산자를 다중정의할 필요가 있음.

### 대입 연산자 다중정의 예시.
    VecF& VecF::operator =(const VecF& fv) {
        if(n != fv.n){
            delete[] arr;
            arr = new float[n = fv.n];
        }
        memcpy(arr, fv.arr, sizeof(float)*n);
        return *this;
    }

### 이동 대입 연산자의 다중정의.
- 좌측 피연산자에 대입할 우측 피연산자가 rvalue일 때 사용됨.
- 대입 후 우측 피연산자의 내용이 더 이상 필요 없는 상황.
- 우측 피연산자의 내용을 좌측 피연산자로 이동하여 불필요한 복사를 피함으로써 효율성을 높일 수 있음.

### 이동 대입 연산자 다중정의 예시.
    VecF& VecF::operator =(VecF&& fv) {
        delete[] arr;           // 기존 메모리를 반환.
        n = fv.n;               // 우측 피연산자의 내용을 이동함.
        arr = fv.arr;
        fv.arr = nullptr;
        return *this;
    }

### std::move 함수.
- 인수로 전달되는 객체의 rvalue 참조를 반환.
- VecF tmp = std::move(v1);
  - v1의 r-value 참조를 구하여 temp의 초기화에 사용.
  - 이동 생성자를 이용하여 tmp 사용.
- 예 : v1 = std::move(v2);
  - v2의 r-value 참조를 구하여 v1에 대입.
  - 이동 대입 연산자 실행.

### std::move 함수의 활용.
    void swapVecF(VecF& v1, VecF& v2) {
        VecF tmp = move(v1);            // 이동 생성자.
        v1 = move(v2);                  // 이동 대입 연산자 사용.
        v2 = move(tmp);                 // 이동 대입 연산자 사용.
    }

------------------------------------------------------------------------------------------------------------

> ## [ ] 연산자의 다중정의.

### SafeIntArray 클래스.
- 요구사항.
  - 배열처럼 지정된 개수의 int 값을 저장할 수 있다. => SafeIntArray a(10); => 10개의 int값을 저장하는 객체.
  - 각각의 값들은 0번부터 시작하는 일련번호를 첨자로 지정하여 액세스한다. => a[5] = 10;
  - 첨자가 지정된 범위를 벗어날 경우 오류 메시지를 출력한 후 프로그램을 종료한다. => cout << a[11];

### [ ] 연산자.
- 배열의 첨자를 지정하는 이항 연산자.
- 피연산자 : 배열과 첨자.
- 데이터를 저장하기 위해 사용할 [ ] 연산자.
  - SafeIntArray a(10);
  - a[5] = 10;

### [ ] 연산자 다중 정의 예시.
    // 배열의 값 변경 가능.
    int& SafeIntArray::operator [](int i) {
        ...
    }

    // 배열의 값 변경 불가능.
    int& SafeIntArray::operator [](int i) const {
        ...
    }

------------------------------------------------------------------------------------------------------------

> ## 문자열 클래스.

### 문자열의 저장.
- 문자열의 끝을 알리기 위해 널(null) 문자('\0') 를 사용함.
  - Null-terminated string.
- 문자열을 저장하기 위한 char 배열.

### MyString 클래스.
- 요구사항.
  - 문자열을 저장하되 다음의 다중정의된 연산자를 포함하며, 실행시 필요에 따라 저장공간을 늘릴 수 있음.
  - = : 대입 연산자, C 스타일 문자열이나 MyString 객체를 복사한다.
  - \+ : 문자열 연결 연산자, 두 문자열을 연결한 문자열을 구한다.
  - += : 문자열을 뒤에 추가한다.
  - == , > , < : 관계연산자, 두 문자열의 등호 및 순서를 비교한다.
  - << : 스트림 출력 연산자, 출력 스트림으로 문자열을 출력한다.
  - [] : 문자열 내의 개별 문자 접근.

### string이란 ?
- 문자열을 저장하기 위한 표준 C++ 라이브러리의 클래스.
- 헤더 파일 : #include <string>
- 연산자 : [ ], +, =, +=, ==, !=, >, >=, <, <=, 스트림 입출력 (<<, >>)등.
- 멤버함수 : length, append, find, c_str 등.
- 함수 : stoi, stod, to_string, swap, getline 등.

------------------------------------------------------------------------------------------------------------

> ### 자료형의 변환.

### 묵시적 형 변환.
- str3 = "Programming";

### 형 변환 ㅎ연산자를 정의하는 위치.
1. 값을 제공하는 송신 측 클래스에서 정의하는 방법.

        class MyString {
            ...
            operator char*() const {
                char* pt = new char[length()+1];
                strcpy(pt, buf);
                return pt;
            }
        }
2. 값을 제공받는 수신 측 클래스에서 정의하는 방법.
   - 문제점 : 송신 측 클래스의 private 멤버를 액세스해야 변환이 가능한 경우 처리 방법을 제공해야 한다.

### 생성자를 이용한 묵시적 형 변환의 금지.
    class MyString {
        ...
        explicit MyString(...)      // explicit 생성자.
    }
1. str = MyString{ "abc" };
2. str = static cas<MyString>("abc");



















