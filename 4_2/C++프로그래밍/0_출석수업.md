 # 출석수업.

--------------------------------------------------------------------------------------------------

> ## C++ 프로그래밍 첫걸음.

### 선행처리.
- C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 것.
- 대표적인 선행처리.
  - 헤더파일 삽입 : #include.
  - 매크로 선언 및 해제 : #define, #undef.
  - 조건부 컴파일 : #if, #ifdef, #ifndef
- C++에서는 .h를 안붙인다.

### cout 객체.
- 표준 출력 스트림 객체.
- 데이터를 문자열로 볍ㄴ환하여 출력함.
- 출력 연산자(삽입 연산자) : << 


### cin 객체.
- 표준 입력 스트림 객체.
- 문자열을 입력 변수의 자료형의 값으로 변환하여 입력함.
- 입력 연산자( 추출 연산자 ) : >> 

### cin 예시.
    int a;
    char str[100];
    std:;cin >> a >> str;
    cout << a << endl ;
    cout << str << endl ;

### 명칭공간이란 ?
- 특정한 이름들이 인식되는 프로그램의 부분.

### 전역변수 사용하기.
    std::cout << ::a;

### 명칭공간 사용하기.
    using namepace std;		// 명칭공간 생략가능.
    std::cout << ::a ; 		=>	cout << ::a ;
    using std::cout ;			// cout만 생략가능.

--------------------------------------------------------------------------------------------------

> ## 변수와 배열.

### 변수.
- 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역.
- 변수에는 이름이 지정되어야 함.
- 모든 변수는 사용하기 전에 미리 선언해야 함.

### 변수의 초기화.
    // C 형식.
    int total = 0;
    // C++ 형식 => 컴파일러가 C++ 형식으로 바꿔서 컴파일 함. (자동형변환)
    int total(0)
    // 집합 형식.
    int total = {0};

### 자료형 추론.
- 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론함.
            
      auto i(10);

### const 한정어.
- 변수의 값을 수정할 수 없게 함.
- 초기화를 통해서만 값을 정할 수 있음.

### 배열.
- 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것.
- 각각의 원소는 0번부터 시작하여 차례로 부여된 번호(첨자, 인덱스)를 이용하여 액세스 함.
- 배열의 차원 : 배열의 첨자 수.
- 배열은 첫 번째 원소의 주소 값을 나타낸다.

### 배열의 초기화.
    // '='는 생략할 수 있음.
    int a[5] = { 1,2,3,4,5 };
    // b[3]와 b[4]는 0으로 초기화됨.
    int b[5] = { 1,2,3 };
    // 배열의 크기는 5임.
    int c[] = { 1,2,3,4,5 };
    
--------------------------------------------------------------------------------------------------

> ## 포인터와 참조.

### 포인터란?
- 다른 변수, 구조체, 객체 등 값이 저장된 곳을 가리키는 변수.
- 포인터 변수에는 주소값을 저장한다.

### 포인터 선언 형식.
    TypeName *ptrVar;
- TypeName : 가리킬 값의 자료형.
- ptrVar : 포인터 변수의 이름.

### 포인터 변수 사용.
    int a = 10;     // 0x100(10)
    int *p = &a;    // 0x300(0x100)
    
    // 동치 : 완벽히 같다.    
    *p = 100; <==> a = 100;

    // 2차원 포인터.
    int **pp = &p;
    **pp = 300; <==> a = 300;
- ptrVar = &var;            // ptrVar에 var의 주소값을 저장함.
- *ptrVar = value;          // ptrVar을 이용하여 var을 액세스.

### 동적 메모리 할당이란?
- 프로그램 동작 중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당하는 것.
  - 기억 공간의 생성 시점 : new 연산자의 실행 시점.
  - 기억 공간의 소멸 시점 : delete 연산자의 실행 시점.
- 포인터 변수가 할당된 기억 공간을 가리키게 함.

### 동적 메모리 할당.
    // 메모리 할당 연산자.
    ptrVar = new TypeName;
    ptrVar = new TypeName[n];

    // 메모리 반납 연산자.
    delete ptrVar;
    delete [] ptrVar;

### 주의사항.
- 상수에는 증감연산자(++, --)를 사용할 수 없다. ( 배열 변수에 사용 못함 )
- 포인터변수는 증감연산자를 사용할 수 있다. ( 배열의 값을 지정할 때 편리하다 )

### 참조란 ? reference.
- 어떠한 대상을 가리키는 값(포인터와 유사함)
- 참조 변수는 참조 대상의 별명처럼 사용할 수 있음.
- l-value 참조 : 실체가 있는 대상(l-value)에 대한 참조.

### l-value 참조 변수의 선언 형식.
    TypeName &refVar = varName;
- TypeName : 참조 대상의 자료형.
- refVar : 참조 변수의 이름.
- varName : 참조 대상.

### const 참조.
- 참조를 이용하여 참조 대상의 값을 바꿀 수 없음.
- 값에 사용만 가능하다.

### 참조 변수가 포인터가 다른 점.
- 참조 변수를 이용하여 값을 읽거나 저장할 때 일반 변수를 사용하는 형식과 동일함.
- 참조 변수는 초기화를 통해 반드시 어떤 대상을 참조해야 함.
- 참조 변수는 초기화를 통해 지정된 참조 대상을 바꿀 수 없어 참조의 유효기간 동안 하나의 대상만 참조할 수 있음.

--------------------------------------------------------------------------------------------------

> ## 함수.

### 함수란 ?
- 필요한 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아 놓고 이름을 부여한 것.
- 함수의 정의된 처리가 필요한 부분에서 호출하여 사용함.
  - 매개변수를 통하여 함수에서 처리할 데이터를 전달함.
  - 호출된 함수로 이동하여 몸체 블록을 실행함.
  - 정해진 처리를 한 후 결과값을 반환할 수 있음.
  - 함수의 실행을 완료하면 호출한 곳으로 복귀함.
- C++ 프로그램은 함수를 기본 단위로 하여 구성됨.

### 주의사항.
- 객체지향에서는 const(불변)을 많이 사용한다.
- 함수 호출부분보다 함수가 먼저 정의되어 있어야 한다.
- 함수가 아래 있어야 하는 경우, 함수의 원형을 헤더 부분에 정의한다.

### 함수의 장점.
- 의미 있는 작업 단위로 모듈화.
- 간결하고 이해하기 쉬운 프로그램을 만들 수 있음.
- 반복 사용되는 코드의 중복 방지.
- 잘 설계된 함수는 다른 응용에서 재사용할 수 있음.

### 함수의 단점.
- 함수 호출과 복귀 과정에서 처리 시간이 추가됨.
- 매우 효율적으로 동작해야 하는 함수라면 inline 함수로 선언해야 함.

### 인수.
- 함수 호출 문장에서 함수에 전달하는 값.
- 매개변수를 통해 인수를 전달함.

### 인수 전달 방법 - 값 호출 call by value.
- 장점.
  - 실 매개변수와 형식 매개변수는 별개의 데이터이므로 불필요한 부작용이 발생하지 않음.
- 단점.
  - 실매개변수의 값을 함수에서 변경하도록 함수를 구현하는 것이 필요한 경우가 있음.
  - 구조체와 같이 많은 양의 데이터로 구성된 인수를 전달할 경우 데이터의 복사량이 많아짐.

### 인수 전달 방법 - 참조 호출 call by reference.
- 실 매개변수의 참조를 형식 매개변수에 전달함.
- 함수에서 형식 매개변수의 값을 변경하는 것은 실 매개변수의 값을 변경하는 것과 같음.
- 형식 매개변수에 복사되는 데이터의 양은 실 매개변수의 크기와 관계 없이 일정함.
- 많은 양의 데이터로 구성되는 구조체나 객체를 인수로 전달하는 경우 효율적임.

### 참조 호출을 통한 효율적인 인수 전달.
- 참조 호출을 사용할 경우 형식 매개변수에 복사되는 데이터의 양은 실 매개변수의 크기와 관계 없이 일정함.

### 참조 예시.
    void intputData(const Circle& c) {
      ...
    }

    int main()
    {
      Circle circle;
      inputData(circle);
      ...
    }

### 디폴트 인수.
- 인수의 디폴트 값을 지정하는 방법.
- 일반적으로 사용되는 디폴트 값이 있는 인수의 경우 함수를 선언할 때 그 값을 미리 지정할 수 있음.

### 함수의 다중정의 overloading.
- 동일한 이름을 갖는 함수를 여러 개 정의하는 것.
- 동일한 개념의 처리를 여러 가지 데이터나 객체에 대해 각각의 대상에 맞는 처리를 해야 할 경우 사용함.
- 다중정의된 함수의 구분 : 인수의 개수 및 자료형.

### 주의사항.
- 함수의 반환 자료형으로 함수를 구분할 수 없음.








