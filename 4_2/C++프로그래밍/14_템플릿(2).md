
# 템플릿(2)

-------------------------------------------------------------------------------------------------------------

> ## 표준 템플릿 라이브러리 STL.

### 표준 템플릿 라이브러리 Standard Template Library 란?
- C++에 제공되는 표준 컨테이너 클래스 템플릿 라이브러리.
- 벡터, 리스트, 스택, 큐 등의 컨테이너와 이들을 처리하기 위해 사용할 수 있는 여러 가지 연산을 포함함.

### STL의 구성 요소.
- 컨테이너 container : 데이터 저장.
- 반복자 iterator : 포인터의 역할.
- 알고리즘 algorithm : 데이터 처리 기능.

### 데이터 저장을 위한 템플릿의 집합.
- int나 float과 같은 기본 자료형 데이터나 사용자 정의 클래스의 객체 등을 저장함.
- 다양한 연산이 제공되어 편리하게 데이터를 활용할 수 있음.
  - 배열 역시 일종의 컨테이너의 역할을 하지만, 배열을 조작하기 위한 연산을 프로그래머가 모두 구현해야 함.

### 순차 컨테이너.
- 동일한 자료형의 객체들을 선형적인 구조로 저장함.
  - vector.
    - 크기의 확장이 가능한 배열.
    - [] 연산자로 지정한 첨자를 이용하여 빠른 직접 접근.
    - 끝에 삽입(또는 삭제)하는 것은 빠르나 그 외의 위치에 삽입(또는 삭제)하는 것은 느림.
  - list.
    - 이중 연결 리스트.
    - 어느 위치든 삽입이나 삭제가 효율적임.
    - 직접 접근이 비효율적이므로 제공하지 않음.
  - deque.
    - vector와 list의 혼합 형태로, 이들의 특성이 모두 필요할 때 사용할 수 있으나 성능은 낮음.

### 연상 컨테이너.
- 탐색 트리와 같은 인덱스 구조를 이용하는 컨테이너.
- 키를 이용한 효율적인 검색 기능을 제공함.
  - set.
    - 키 객체만 저장하며, 키가 중복되지 않음.
  - multiset.
    - 키 객체만 저장하며, 동일한 키가 중복될 수 있음.
  - map.
    - 키 객체, 값 객체의 쌍을 저장.
    - 키가 중복되지 않음.
  - multimap.
    - 키 객체, 값 객체의 쌍을 저장.
    - 동일한 키가 중복될 수 있음.

### 무순서 연상 컨테이너.
- 연상 컨테이너처럼 키를 이용한 검색기능을 제공.
- 해시함수를 이용하여 데이터 검색 시간이 일정함.
  - unordered_set
  - unordered_multiset.
  - unordered_map.
  - unordered_multimap.
    - set, multiset, map, multimap 과 같으나 해시함수를 이용하여 저장 및 검색을 함.

### 컨테이너 어뎁터.
- 기본 컨테이너를 기반으로 특정 용도에 맞게 유도된 컨테이너. 
  - queue.
    - FIFO First In First Out 구조.
  - priority_queue.
    - 우선순위에 따라 데이터를 액세스할 수 있는 구조.
  - stack.
    - LIFO Last In, First Out 구조.
  
### 반복자 iterator 란?
- 포인터의 개념이 일반화된 것.
- 컨테이너의 유형에 따라 서로 다른 형태의 반복자가 사용됨.

### 순방향 forward 반복자.
- 컨테이너의 순방향으로만 움직일 수 있음.
- ++연산자 사용.

### 양방향 bidirectional 반복자.
- 컨테이너의 순방향과 역방향으로 움직일 수 있음.
- ++, --연산자 사용.

### 랜덤 액세스 반복자.
- 양방향 반복자의 기능과 함께 임의의 위치로 이동할 수 있음.

### 알고리즘.
- 컨테이너의 원소에 대해 적용할 수 있는 여러 가지 연산.
    - search : 지정된 값과 동일한 첫 번째 원소를 반환.
    - count : 지정된 값을 갖는 원소의 수를 반환.
    - swap : 컨테이너 안의 값을 교환.
    - sort : 컨테이너의 값들을 지정된 순서에 따라 정렬.
    - merge : 두 정렬된 영역의 원소들을 합병.
    - reverse : 지정된 범위의 원소들을 역순으로 나열.
    - remove : 컨테이너에서 지정된 값을 제거.
    - replace : 지정된 값을 다른 값으로 대체.
    - unique : 인접 위치에 있는 중복된 값을 제거.
    - for_each : 지정된 함수를 컨테이너의 모든 원소에 적용.

-------------------------------------------------------------------------------------------------------------

> ## STL 활용 예 - vector.

### vector 란?
- 1차원 배열의 개념을 구현한 순차 컨테이너 유형의 클래스 템플릿.
- 배열의 일반적인 기능을 포함하면서 여러 가지 유용한 멤버함수 및 관리 기능이 도입되어 있음.
- 배열처럼 ㅡ기가 고정되어 있지 않고 필요에 따라 저장 공간을 확장할 수 있음.
- 필요한 헤더 파일 : <vector>

### vecetor 객체의 선언 구문.
    vector<float> fVector(10);

### [] 연산자.
- vector에 대한 직접접근 연산자.
- 배열처럼 첨자를 이용하여 원소를 직접접근할 수 있게 함.

### [] 연산자 사용 예.
    vector<float> fVector(10);
    fVector[2] = 10.0f;
    cout << fVector[2];
- 첨자가 올바른 범위의 값인지 확인이 필요함.

### 멤버함수 at().
- 직접접근을 위한 멤버함수.
- 첨자의 범위를 검사함 : 지정된첨자가 범위를 벗어날 경우 에외 발생.

### at() 함수의 사용 예.
    vector<int> iVector = { 1,2,3,4 };
    iVector.at(2) = 10;
    cout << iVector.at(4) << endl;   // 예외 발생.

### 멤버함수 size()와 capacity().
- vector에 크기는 실행 중 확장할 수 있음.
  - 미래의 호가장에 대비하여 여분의 공간을 미리 확보할 수 있음.
  - 논리적인 vector의 크기와 실제 할당된 메모리의 크기는 다를 수 있음.

### 멤버함수 push_back() 과 pop_back().
- vector의 끝에 데이터를 저장하거나 꺼냄.

### 멤버함수 insert() 와 erase().
- vector의 지정된 위치에 데이터를 삽입하거나 삭제함.
  - 함수의 실행에 따라 size()의 값은 증가하거나 감소함.
  - capacity()의 값은 데이터 추가로 인해 확보된 메모리가 부족하여 확장될 때 바뀜.

### 반복자의 선언.
    // 반복자의 선언.
    vector<int> intVec(5);
    vector<int>::iterator it = intVec.begin();

    // 간단표현.
    auto it = intVec.begin();

### 반복자의 값을 구하는 vector의 멤버함수.
- begin() : 첫 번째 원소를 가리키는 랜덤 액세스 반복자를 반환함.
- end() : 마지막 우너소의 다음 위치를 가리키는 랜덤 액세스 반복자를 반환함.

-------------------------------------------------------------------------------------------------------------

> ## 알고리즘의 활용.

### sort()의 용법.
- 랜덤 액세스 반복자에 의해 지정된 범위의 값들을 정렬함.
    1. sort(first, last);
    2. sort(first, last, comp);
        - first : 정렬할 범위의 시작 원소에 대한 포인터.
        - last : 정렬할 범위의 마지막 원소의 다음 위치에 대한 포인터.
        - comp : 정렬 순서를 정하는 함수.

### merge()의 용법.
- 동일한 기준으로 정렬된 두 개의 데이터 집합을 동일한 기준으로 정렬된 하나의 데이터 집합으로 결합하는 함수.
    1. merge(first1, last1, first2, last2, dest);
    2. merge(first1, last1, first2, last2, dest, comp);
        - first1, last1 : 첫 번째 정렬된 데이터의 범위.
        - first2, last2 : 두 번째 정렬된 데이터의 범위.
        - dest : 합병 결과가 저장될 시작 위치.
        - comp : 합병 순서를 정하는 함수.

### 알고리즘의 활용 예.
    ...
    #include <vector>
    #include <algorithm>
    ...

    int main()
    {
        srand((unsigned)time(NULL));
        
        vector<int> iv1(5);
        for(auto& i : iv1) {
            i = rand() % 100;
            cout << i << " " ;
        }

        sort(iv1.begin(), iv1.end());
        
        for(auto i : iv1) {
            cout << i << " " ;
        }
        ...
    }   

### 함수객체를 이용한 콜백함수 전달.
    template<typename T> class GREATER {
    public:
        bool operator()(const T& a, const T& b) const {
            return a > b;
        }
    }
    
    GREATER<int> greaterthan;
    if(greaterthan(20,10) {
        cout << "20은 10보다 큼";
    };
- 함수 객체 : 함수처럼 사용될 수 있는 객체.

-------------------------------------------------------------------------------------------------------------

> ## STL 활용 예 - map.

### map 이란?
- 저장하는 데이터의 형태 키, 값의 쌍.
- 키를 이용하여 데이터에 직접접근할 수 있는 연상 컨테이너.
  - 키 : 데이터 집합에서 특정 데이터를 검색하거나 데이터의 집합을 정렬하는 등의 처리에 기준이 되는 속성.
- map에 저장되는 데이터는 키가 모두 다름.
- 트리 형태의 데이터 구조를 이용함으로써 검색 시간이 데이터 수의 로그 함수에 비례함.
- 필요함 헤더파일 : <map>

### map 객체의 선언.
    map<string, string> addrbook.
- 기본값으로 키 , 값의 순서대로 저장한다.

### insert() 함수.
    map<string, string> addrbook;
    addrbook.insert( make_pait( "김철수" , "서울시 종로구" ) );
    addrbook.insert( { "홍길동", "서울시 중구" });

### [] 연산자.
    addrbook["key"] = "값" ;
- 키를 이용한 데이터 직접접근.

### find() 함수를 이용한 검색.
    auto if = addrbook.find("키");
- 지정된 키를 갖는 데이터를 가리키는 반복자 반환.
- 키에 맞는 값이 없으면 addrbook.end()가 저장됨.

### erase() 함수를 이용한 데이터 삭제.
    addrbook.erase("키");
    addrbook.erase(범위1, 범위2);
- 키가 가리키는 데이터 삭제.
- [범위1, 범위2)에 포함되는 데이터를 삭제.








