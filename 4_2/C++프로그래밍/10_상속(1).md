
# 상속(1)

-----------------------------------------------------------------------------------------------------------

> ## 기초 클래스와 파생 클래스.

### 클래스의 상속.
- 공통적인 멤버를 포함하는 유사한 유형의 클래스.
- 일반화와 특수화를 통한 클래스 계층구조 설계.

### 파생 클래스 선언 형식.
    class DClassName : visibilitySpec BClassName {
        // 데이터 멤버 또는 멤버함수 리스트;
    }

### Person 클래스와 Student 클래스.
    ...
    class Person {
        string name;
    public:
        ...
        void print() const { cout << name; }
    };
    ...
    
    class Student : public Person {
        string school;
    public:
        ...
        void print() const {
            Person::print();
            cout << "goes to "" << school;
        }
    };
    ...

### 클래스 계층.
1. 트리 구조.
2. 그래프 구조. (이중 상속)

-----------------------------------------------------------------------------------------------------------

> ## 파생 클래스의 생성자 및 소멸자.

### 생성자 선언 형식.

    DclassName(fParameterList) : BClassName(bArgsList){
        // 파생 클래스 생성자에서 추가되는 사항.
    }
- DClassName : 파생 클래스 생성자 (파생 클래스 이름을 사용)
- BClassName : 기초 클래스 생성자 (기초 클래스 이름을 사용)
- fParameterList : 파생 클래스 생성자 형식 매개변수 목록.
- bArgsList : 기초 클래스 생성자에 전달할 인수 목록.

### 생성자의 실행순서.
- 기초 클래스 생성자 -> 파생 클래스 생성자.
- 파생 클래스는 기초 클래스의 내용을 바탕으로 하고 있음.
- 객체의 기초 클래스 해당 내용이 먼저 준비된 후 파생 클래스에 선언된 내용을 초기화할 필요가 있음.

### 소멸자의 실행순서.
- 파생 클래스 소멸자 -> 기초 클래스 소멸자.
- 기초 클래스의 속성이 제거되기 전에 이를 활용할 가능성이 있는 파생 클래스 객체를 제거해야 함.

-----------------------------------------------------------------------------------------------------------

> ## 액세스 제어.

### 가시성 지시어.
- private(디폴트)
  - 소속 클래스의 멤버함수.
  - 친구 클래스의 멤버함수 및 친구함수.
- protected.
  - 소속 클래스의 멤버함수.
  - 친구 클래스의 멤버함수 및 친구 함수.
  - 파생 클래스의 멤버함수.
  - 파생 클래스의 친구 클래스의 멤버함수 및 친구 함수. 
- public.
  - 전 범위.

### 기초클래스로부터 상속받은 멤버의 가시성.
    class C1 : visibilitySpec P1 { ... }
- visibilitySpec.
  - 기초 클래스로부터 상속된 멤버가 파생클래스의 멤버로서 가지게 되는 가기성을 제어함.
  - class를 선언할 때는 private이 디폴트, struct를 선언할 때는 public이 디폴트임.
  - visibilitySpec에 지시된 가시성의 상한이 되도록 제한됨.

-----------------------------------------------------------------------------------------------------------

> ## 심화 학습.

### final 클래스.
    class C final : public P { ... } 
- 파생 클래스 선언의 금지.
- final은 키워드가 아닌 식별자임.
- final을 정해진 위치에 사용되지 않은 경우 다른 용도로 사용할 수도 있음. (바람직한 용법은 아님)

### 이름 은폐 name hiding.
    void f(int x) {
        ...
    }
    void f(double x) {
        ...
    }
    int main() {
        void f(int x);        // main { }안에서 함수를 새로 선언했기 때문에 선언한 함수만 사용할 수 있다.
        f(10);
        f(20.0);
        ::f(30.0);            // :: 라는 전역 표시를 선언해서 전역 함수를 사용할 수 있다.
    }
- 어떠한 영역에 선언된 이름을 그 영역에 내포된 영역에서 다시 선언하면 내포된 영역에서는 바깥 영역의 이름이 은폐됨.

### 클래스 상속에서의 이름 은폐.
- 기초 클래스에 선언된 이름을 파생 클래스에서 재정의하면 파생 클래스의 객체에서 기초 클래스의 이름이 은폐됨.


















