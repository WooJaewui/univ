# 힢.

------------------------------------------------------------------------------------------------------------

> ## 우선순위 큐.

### 우선순위 큐.
- 큐 : 먼저 들어간 데이터가 먼저 삭제되는 자료구조 먼저 줄을 선 사람이 먼저 서비스를 받는 구조.
- 우선순위 큐 : 대기 리스트에서 항상 우선순위가 높은 사람이 먼저 서비스를 받는 구조.

### 우선순위 큐의 배열 구현.
- Delete_q() : 큐의 front에 있는 값이 삭제하고, 다음으로 우선순위가 높은 값을 front로 이동.
- Add_q(value) : 배열에 마지막 자리에 값(value)을 추가.

### 우선순위 큐의 작동 방식.
1. 삭제 명령이 샐행되면 저장된 데이터 중에서 가장 작은 값이 삭제된다.
2. 나머지 데이터들은 어떤 순서로 저장되든 문제가 되지 않는다.

------------------------------------------------------------------------------------------------------------

> ## 힢.

### 힢의 정의.
- 피라미드 모양으로 쌓아 올린 더미.
- 무엇인가를 쌓아놓은 더미이고 항상 가장 위에 있는 것을 우선 꺼내는 구조.
- 부모-자식 노드사이에서(부분적으로) 정렬된 완전 이진트리로 부모노드는 자식노드보다 우선순위가 높음.

### 최소 힢.
- 루트가 전체 노드 중에서 최소값인 힙.
- 트리의 모든 노드가 자식 노드보다 작은 값을 가짐.
- 트리의 레벨에 따라 데이터가 순서를 갖지는 않음.
- 탐색 트리처럼 왼쪽 노드와 오른쪽 노드 사이에 크기 제한도 없음.
- 루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 가짐.

### 최대 힙.
- 루트가 전체 노드 중에서 최대값인 힙.
- 트리의 모든 노드가 자식 노드보다 큰 값을 가짐.
- 트리의 레벨에 따라 데이터가 순서를 갖지는 않음.
- 탐색 트리처럼 왼쪽 노드와 오른쪽 노드 사이에 크기 제한도 없음.
- 루트가 가장 큰 값을 갖고 부모는 자식보다 큰 값을 가짐.

------------------------------------------------------------------------------------------------------------

> ## 힙 노드의 삭제 및 삽입.

### 배열을 이용한 힙의 구현.
- 완전 이진트리이기 때문에 배열로 구현해도 기억장소 낭비가 없음.
- 연결 리스트보다 실행 속도 면에서 효율적임.
- 기억장소 측면에서도 장점을 가짐.

### 힙의 노드 삭제.
    typedef struct {
        int heap[MAX_Data];
        int heap_size;
    } HeapType;

    int deleteHeap(HeapType *h) {
        int parent, child;
        int item, temp;

        item = h->heap[1];
        temp = h->heap[(h->heap_size)];
        parent = 1; child=2;
    }
- 루트 노드의 값을 삭제하고, 마지막 리프 노드를 루트 노드로 이동시켜 우선순위를 확인.

### 힙의 노드 삽입.
- 완전이진 트리의 마지막 리프노드 위치에 노드를 추가해준다.
- 추가한 노드와 부모 노드사이에 우선순위를 확인한다.


























