
# 멀티웨이 탐색 트리(2)

------------------------------------------------------------------------------------------------------------

> ## 2-3트리.

### 2-3트리.
- 차수가 2 또는 3인 내부 노드를 갖는 탐색 트리.
- 2-노드와 3-노드만으로 구성되는 특수한 형태의 B트리임.
- 2-노드 혹은 3-노드라는 제약이 내부 노드에만 해당함.
  - 모든 잎 노드는 같은 레벨에 있어야 한다는 제약만 존재함.

### 2-3트리의 조건.
- 각각의 내부 노드는 2-노드이거나 3-노드이다.
- 2-노드는 1개의 키값을, 3-노드는 2개의 키값을 갖는다.
- 2-노드인 경우, lchild, mchild라고 부른다.
- 3-노드인 경우 lchild, mchild, rchild라고 부른다.
- 왼쪽은 항상 오른쪽보다 작다. (암묵적인 룰)
- 모든 잎 노드는 같은 레벨에 있다. 

### 2-3 트리의 삭제.
- 2-3 트리의 삭제에서 잎 노드가 아닌 노드의 키를 삭제하면 그곳을 다른 키로 대체해야 함.
- 일반적으로 삭제한 키의 왼쪽 서브트리에서 가장 큰 키값이나 오른쪽 서브트리에서 가장 작은 키값을 선택하여 대체함.
- 최대한 트리를 변경하지 않는 선에서 삭제해야 함. 

------------------------------------------------------------------------------------------------------------

> ## 2-3-4 트리.

### 2-3-4 트리.
- 2-3 트리를 확장하여 4개의 자식을 가진 4-노드를 허용하는 탐색 트리.
- 2-3-4 트리는 2-3 트리보다 삽입과 삭제가 용이함.
- 2-3-4 트리에서는 2-노드와 3-노드에 대한 트리 재구성 확률이 2-3 트리에서보다 작기 때문에 삽입 및 삭제 연산을 수행하는 데 더 효율적임.
- 빈 공간이 생겨 메모리가 낭비된다.

### 2-3-4 트리의 조건.
- lchild, lmchild, rmchild, rchild가 존재함.

### 2-3-4 트리의 삽입 연산.
- 2-3-4 트리에서는 2-노드와 3-노드에 대한 트리 재구성의 확률이 2-3 트리에서 보다 작기 때문에 삽입/삭제 연산이 효율적임.
- 삽입 연산 시 문제가 되는 4-노드는 그 위치에 따라 세 가지 경우로 구분하여 분리함.
  - 4-노드가 루트인 경우. (노드를 재구성)
  - 4-노드의 부모가 2-노드인 경우. (부모 노드에 값을 보낸다)
  - 4-노드의 부모가 3-노드인 경우. (부모 노드에 값을 보낸다)

------------------------------------------------------------------------------------------------------------

> ## 레드 블랙 트리.

### 레드 블랙 트리의 정의.
- 효율적인 기억 장소 사용을 위하여 2-3-4 트리를 이진 트리로 나타낸 탐색 트리.
- 레드 간선과 블랙 간선의 서브트리 포인터를 가짐.
- 레드 간선은 2-3-4 트리의 한 노드 내에 있던 노드의 관계이고, 블랙 간선은 2-3-4 트리의 부모-자식 관계임.
- 레드 블랙 트리의 탐색 방법은 보통의 이진 탐색 트리의 탐색 알고리즘과 동일함.
- 2진 트리로 변경하는 이유는 메모리의 낭비를 줄이기 위해서다.




















